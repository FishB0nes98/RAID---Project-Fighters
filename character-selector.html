<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Selector</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Nunito:wght@400;600;700&display=swap">
    <!-- New: Reuse raid-game styles for unified quest panel -->
    <link rel="stylesheet" href="css/raid-game.css">
    <!-- Selector-specific overrides -->
    <style id="selector-overrides">
      /* Restore scrolling and normal body dimensions */
      body { height: auto !important; overflow-y: auto !important; }
      /* Quest panel scrolling */
      .quests-panel { max-height: 85vh; overflow-y: auto; }
      /* Hide completed quests */
      .quests-panel .quest-item.completed { display: none; }
    </style>
    <style>
        :root {
            /* Main color scheme */
            --primary: #5463ff;
            --primary-dark: #3a45bd;
            --primary-light: #8894ff;
            --secondary: #ff6b6b;
            --secondary-dark: #d85757;
            --secondary-light: #ff9999;
            --neutral-900: #111827;
            --neutral-800: #1f2937;
            --neutral-700: #374151;
            --neutral-600: #4b5563;
            --neutral-500: #6b7280;
            --neutral-400: #9ca3af;
            --neutral-300: #d1d5db;
            --neutral-200: #e5e7eb;
            --neutral-100: #f3f4f6;
            --neutral-50: #f9fafb;
            
            /* Rarities */
            --legendary: #ffbd00;
            --epic: #b362ff;
            --rare: #4dabf5;
            --common: #6bddaa;
            
            /* Difficulty colors */
            --easy: #4ade80;
            --medium: #fb923c;
            --hard: #f87171;
            
            /* UI Elements */
            --bg-dark: #12141f;
            --bg-card: #1a1c2a;
            --bg-hover: #23253a;
            --bg-selected: #2a2c42;
            --border-light: rgba(255, 255, 255, 0.1);
            --elevation-1: 0 2px 10px rgba(0, 0, 0, 0.15);
            --elevation-2: 0 4px 16px rgba(0, 0, 0, 0.2);
            --elevation-3: 0 8px 24px rgba(0, 0, 0, 0.3);
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --glow: 0 0 15px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--bg-dark);
            color: var(--neutral-100);
            line-height: 1.5;
            background-image: 
                radial-gradient(circle at 10% 10%, rgba(84, 99, 255, 0.05), transparent 40%),
                radial-gradient(circle at 90% 90%, rgba(255, 107, 107, 0.05), transparent 40%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            line-height: 1.2;
        }
        
        .app-container {
            max-width: 1440px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header Section */
        .app-header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }
        
        .app-header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(135deg, var(--primary-light), var(--secondary-light));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            display: inline-block;
            padding: 0 20px;
            letter-spacing: 0.5px;
        }
        
        .app-header h1::before,
        .app-header h1::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 80px;
            height: 2px;
            background: linear-gradient(to right, transparent, var(--primary));
        }
        
        .app-header h1::before {
            right: 100%;
        }
        
        .app-header h1::after {
            left: 100%;
            background: linear-gradient(to left, transparent, var(--secondary));
        }

        /* Header Buttons Container */
        .header-buttons {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Navigation Buttons */
        .nav-button {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: var(--radius-md);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--elevation-1);
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Montserrat', sans-serif;
            position: relative;
            overflow: hidden;
        }

        .nav-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg) translateX(-100%);
            transition: transform 0.6s ease;
        }

        .nav-button:hover::before {
            transform: rotate(45deg) translateX(100%);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(84, 99, 255, 0.4);
        }

        .nav-icon {
            width: 14px;
            height: 14px;
            display: inline-block;
        }

        /* Changelog Button */
        .changelog-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius-md);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--elevation-2);
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Montserrat', sans-serif;
            position: relative;
            overflow: hidden;
        }

        .changelog-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg) translateX(-100%);
            transition: transform 0.6s ease;
        }

        .changelog-button:hover::before {
            transform: rotate(45deg) translateX(100%);
        }

        .changelog-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .changelog-icon {
            width: 16px;
            height: 16px;
            display: inline-block;
        }

        /* Version Badge */
        .version-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 4px 6px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
            animation: pulse-badge 2s infinite;
        }

        @keyframes pulse-badge {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Changelog Modal */
        .changelog-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .changelog-modal.show {
            display: flex;
            opacity: 1;
        }

        .changelog-content {
            background: linear-gradient(135deg, #1a1c2a 0%, #23253a 100%);
            border-radius: var(--radius-lg);
            padding: 0;
            max-width: 800px;
            max-height: 90vh;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-light);
            overflow: hidden;
            position: relative;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .changelog-modal.show .changelog-content {
            transform: scale(1);
        }

        .changelog-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 25px 30px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .changelog-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .changelog-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .changelog-version {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .changelog-subtitle {
            margin: 8px 0 0 0;
            font-size: 1rem;
            opacity: 0.9;
            font-weight: 400;
        }

        .changelog-close {
            position: absolute;
            top: 20px;
            right: 25px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .changelog-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .changelog-body {
            padding: 30px;
            max-height: calc(90vh - 120px);
            overflow-y: auto;
            color: var(--neutral-100);
        }

        .changelog-section {
            margin-bottom: 30px;
        }

        .changelog-section h3 {
            color: var(--primary-light);
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .character-changes {
            background: var(--bg-hover);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid;
            position: relative;
        }

        .character-changes.siegfried { border-left-color: #fbbf24; }
        .character-changes.kokoro { border-left-color: #10b981; }
        .character-changes.ayane { border-left-color: #8b5cf6; }
        .character-changes.elphelt { border-left-color: #f472b6; }
        .character-changes.shoma { border-left-color: #06b6d4; }

        .character-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .character-emoji {
            font-size: 1.2rem;
        }

        .character-rationale {
            font-size: 0.9rem;
            color: var(--neutral-400);
            margin-bottom: 12px;
            font-style: italic;
        }

        .change-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .change-item {
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
        }

        .change-arrow {
            color: var(--primary-light);
            font-weight: bold;
        }

        .developer-notes {
            background: linear-gradient(135deg, rgba(84, 99, 255, 0.1), rgba(255, 107, 107, 0.1));
            border-radius: var(--radius-md);
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(84, 99, 255, 0.2);
        }

        .notes-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }

        /* Scrollbar Styling */
        .changelog-body::-webkit-scrollbar {
            width: 8px;
        }

        .changelog-body::-webkit-scrollbar-track {
            background: var(--bg-hover);
            border-radius: 10px;
        }

        .changelog-body::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 10px;
        }

        .changelog-body::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }
        
        /* Main Content Layout */
        .content-wrapper {
            display: flex;
            gap: 25px;
            margin-bottom: 25px;
            flex: 1;
        }
        
        /* Selector Panel Shared Styles */
        .selector-panel {
            flex: 1;
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 20px;
            box-shadow: var(--elevation-2);
            position: relative;
            border: 1px solid var(--border-light);
            overflow: hidden;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .selector-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            opacity: 0.8;
        }
        
        .panel-header {
            margin-bottom: 20px;
        }
        
        .panel-header h2 {
            font-size: 1.6rem;
            color: var(--neutral-100);
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .panel-header p {
            font-size: 0.9rem;
            color: var(--neutral-400);
            font-weight: 300;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--neutral-700);
        }
        
        .tab-button {
            background: transparent;
            border: none;
            color: var(--neutral-400);
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            font-family: 'Montserrat', sans-serif;
        }
        
        .tab-button::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 0;
            height: 3px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            transition: width 0.2s ease;
        }
        
        .tab-button:hover {
            color: var(--neutral-100);
        }
        
        .tab-button.active {
            color: var(--neutral-50);
        }
        
        .tab-button.active::after {
            width: 100%;
        }
        
        .tab-content {
            display: none;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--neutral-800);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--neutral-600);
            border-radius: 10px;
            border: 2px solid var(--neutral-800);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--neutral-500);
        }
        
        /* Story Section */
        .story-container {
            margin-bottom: 30px;
            position: relative;
            padding: 15px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            border: 1px solid transparent;
            background-color: rgba(255,255,255,0.02);
        }
        
        .story-container:hover {
            background-color: rgba(255,255,255,0.04);
            transform: translateY(-2px);
        }
        
        .story-container.selected {
            border: 1px solid var(--primary);
            background-color: rgba(84, 99, 255, 0.1);
            box-shadow: 0 0 10px rgba(84, 99, 255, 0.2);
        }
        
        .story-container.locked {
            filter: grayscale(70%);
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .story-container.locked:hover {
            transform: none;
            background-color: rgba(255,255,255,0.02);
        }
        
        .story-title {
            font-size: 1.2rem;
            color: var(--neutral-100);
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--neutral-700);
            display: flex;
            align-items: center;
            font-weight: 600;
        }
        
        .story-title::before {
            content: "⚔️";
            margin-right: 8px;
            font-size: 1rem;
        }
        
        .story-description {
            font-size: 0.9rem;
            color: var(--neutral-400);
            margin-bottom: 15px;
            padding-left: 10px;
            border-left: 2px solid var(--primary-dark);
            font-style: italic;
        }
        
        /* Stage Grid */
        .stage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
        }
        
        .stage-card {
            background-color: var(--bg-card);
            border-radius: var(--radius-sm);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            position: relative;
            border: 1px solid var(--border-light);
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .stage-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--elevation-2);
            border-color: var(--primary-light);
            background-color: var(--bg-hover);
        }
        
        .stage-card.selected {
            border: 2px solid var(--primary);
            box-shadow: 0 0 15px rgba(84, 99, 255, 0.3);
            background-color: var(--bg-selected);
        }
        
        .stage-card.locked {
            filter: grayscale(70%);
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .stage-card.locked:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-light);
            background-color: var(--bg-card);
        }
        
        .stage-lock-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .stage-image {
            width: 100%;
            height: 0;
            padding-bottom: 75%;
            background-color: var(--neutral-800);
            background-size: cover;
            background-position: center;
            position: relative;
        }
        
        .stage-image img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .stage-number {
            position: absolute;
            left: 10px;
            top: 10px;
            width: 26px;
            height: 26px;
            background-color: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 5;
        }
        
        .story-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 5;
        }
        
        .stage-info {
            padding: 12px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        
        .stage-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 6px;
            color: var(--neutral-100);
        }
        
        .stage-desc {
            font-size: 0.85rem;
            color: var(--neutral-400);
            flex-grow: 1;
        }
        
        .difficulty-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            color: var(--neutral-100);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .difficulty-easy {
            background-color: rgba(74, 222, 128, 0.2);
            color: var(--easy);
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .difficulty-medium {
            background-color: rgba(251, 146, 60, 0.2);
            color: var(--medium);
            border: 1px solid rgba(251, 146, 60, 0.3);
        }
        
        .difficulty-hard {
            background-color: rgba(248, 113, 113, 0.2);
            color: var(--hard);
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        /* Filter Section */
        .filter-container {
            margin-bottom: 15px;
        }
        
        .tag-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .tag-filter-button {
            background-color: var(--bg-hover);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            color: var(--neutral-400);
            padding: 6px 14px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Montserrat', sans-serif;
        }
        
        .tag-filter-button:hover {
            background-color: var(--bg-selected);
            color: var(--neutral-200);
            border-color: var(--primary-light);
        }
        
        .tag-filter-button.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary-dark);
        }
        
        /* Character Grid */
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .character-card {
            background-color: var(--bg-card);
            border-radius: var(--radius-sm);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            border: 1px solid var(--border-light);
            position: relative;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--elevation-2);
            border-color: var(--primary-light);
            background-color: var(--bg-hover);
        }
        
        .character-card.selected {
            border: 2px solid var(--secondary);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.3);
            background-color: var(--bg-selected);
        }
        
        .character-card.hidden {
            display: none;
        }
        
        .character-card.locked {
            filter: grayscale(90%);
            cursor: not-allowed;
        }
        
        .character-card.locked:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-light);
            background-color: var(--bg-card);
        }
        
        .character-card.restricted {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .lock-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: white;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
            pointer-events: none;
        }
        
        .character-card.locked .lock-overlay {
            opacity: 1;
        }
        
        .character-image {
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            background-color: var(--neutral-800);
            position: relative;
            overflow: hidden;
        }
        
        .character-image img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center top;
            transition: transform 0.3s ease;
        }
        
        .character-card:hover .character-image img {
            transform: scale(1.05);
        }
        
        .character-image .no-image, 
        .stage-image .no-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            color: var(--neutral-500);
            background-color: var(--neutral-800);
            text-align: center;
            font-style: italic;
        }
        
        .character-info {
            padding: 12px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        
        .character-name {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 6px;
            color: var(--neutral-100);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .character-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
        }
        
        .character-tag {
            background-color: rgba(84, 99, 255, 0.15);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.65rem;
            color: var(--neutral-300);
        }
        
        .rarity-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .rarity-badge::before {
            content: "★";
            font-size: 0.8rem;
        }
        
        .rarity-legendary {
            background-color: rgba(255, 189, 0, 0.2);
            color: var(--legendary);
            border: 1px solid rgba(255, 189, 0, 0.3);
        }
        
        .rarity-epic {
            background-color: rgba(179, 98, 255, 0.2);
            color: var(--epic);
            border: 1px solid rgba(179, 98, 255, 0.3);
        }
        
        .rarity-rare {
            background-color: rgba(77, 171, 245, 0.2);
            color: var(--rare);
            border: 1px solid rgba(77, 171, 245, 0.3);
        }
        
        .talents-button {
            display: block;
            width: 100%;
            margin-top: auto;
            padding: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--neutral-200);
            background-color: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .talents-button:hover {
            background-color: rgba(255, 107, 107, 0.25);
            color: var(--secondary-light);
        }

        /* Talent Point Indicator */
        .talent-points-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #1f2937;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
            animation: talent-pulse 2s infinite ease-in-out;
        }

        .talent-points-indicator.hidden {
            display: none;
        }

        @keyframes talent-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 4px 16px rgba(251, 191, 36, 0.6);
            }
        }

        .talent-points-indicator::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-radius: 50%;
            z-index: -1;
            opacity: 0.3;
            animation: talent-glow 2s infinite ease-in-out;
        }

        @keyframes talent-glow {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }
        
        /* Team Preview Section */
        .team-preview {
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 20px;
            box-shadow: var(--elevation-2);
            margin-top: auto;
            border: 1px solid var(--border-light);
            position: relative;
        }
        
        .team-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, var(--secondary), var(--primary));
            opacity: 0.8;
        }
        
        .team-preview h2 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--neutral-100);
            position: relative;
            display: inline-block;
            padding-bottom: 8px;
            margin: 0 auto 20px;
            width: 100%;
            text-align: center;
        }
        
        .team-preview h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 30%;
            right: 30%;
            height: 2px;
            background: linear-gradient(to right, transparent, var(--secondary), var(--primary), transparent);
        }
        
        .team-slots {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 25px;
        }
        
        .team-slot {
            width: 70px;
            height: 70px;
            background-color: var(--bg-hover);
            border-radius: var(--radius-sm);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            color: var(--neutral-500);
            transition: all 0.3s ease;
            border: 1px dashed var(--neutral-700);
            position: relative;
            overflow: hidden;
        }
        
        .team-slot.hidden {
            display: none;
        }
        
        .team-slot.filled {
            background-color: var(--bg-selected);
            background-size: cover;
            background-position: center top;
            border: 1px solid var(--secondary);
            color: var(--neutral-100);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.2);
        }
        
        .team-slot.filled::after {
            content: "✕";
            position: absolute;
            top: -5px;
            right: -5px;
            width: 22px;
            height: 22px;
            background-color: var(--secondary);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .team-slot.filled:hover::after {
            opacity: 1;
            top: 5px;
            right: 5px;
        }
        
        .team-slot.filled img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .team-slot.invalid {
            border: 2px dashed var(--secondary);
            background-color: rgba(255, 107, 107, 0.1);
        }
        
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .action-button {
            min-width: 150px;
            padding: 12px 24px;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.7s ease;
        }
        
        .action-button:hover::before {
            left: 100%;
        }
        
        .start-button {
            background-color: var(--primary);
            color: white;
            box-shadow: 0 4px 0 var(--primary-dark);
        }
        
        .start-button:hover {
            background-color: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 var(--primary-dark);
        }
        
        .start-button:active {
            transform: translateY(2px);
            box-shadow: 0 0 0 var(--primary-dark);
        }
        
        .back-button {
            background-color: var(--neutral-700);
            color: var(--neutral-200);
            box-shadow: 0 4px 0 var(--neutral-900);
        }
        
        .back-button:hover {
            background-color: var(--neutral-600);
            color: var(--neutral-100);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 var(--neutral-900);
        }
        
        .back-button:active {
            transform: translateY(2px);
            box-shadow: 0 0 0 var(--neutral-900);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            max-width: 650px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 25px;
            position: relative;
            box-shadow: var(--elevation-3);
            border: 1px solid var(--neutral-700);
            animation: modalFadeIn 0.3s forwards;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--neutral-400);
            transition: color 0.3s;
            z-index: 10;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .close-modal:hover {
            color: var(--secondary);
            background-color: var(--bg-hover);
        }
        
        .modal-stage-image {
            width: 100%;
            height: 200px;
            background-color: var(--neutral-800);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--neutral-600);
            margin-bottom: 20px;
            border-radius: var(--radius-sm);
            position: relative;
            overflow: hidden;
        }
        
        .modal-stage-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }
        
        .modal-title {
            font-size: 1.8rem;
            color: var(--neutral-100);
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .modal-story-title {
            display: flex;
            align-items: center;
            color: var(--primary-light);
            font-size: 1.2rem;
            margin: 20px 0 15px;
            border-bottom: 1px solid var(--neutral-700);
            padding-bottom: 10px;
        }
        
        .story-icon {
            margin-right: 10px;
            color: var(--secondary);
        }
        
        .modal-description {
            color: var(--neutral-300);
            line-height: 1.6;
            margin-bottom: 20px;
            font-size: 1rem;
        }
        
        .modal-difficulty {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .modal-difficulty.difficulty-easy {
            background-color: rgba(74, 222, 128, 0.1);
            color: var(--easy);
            border: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .modal-difficulty.difficulty-medium {
            background-color: rgba(251, 146, 60, 0.1);
            color: var(--medium);
            border: 1px solid rgba(251, 146, 60, 0.3);
        }
        
        .modal-difficulty.difficulty-hard {
            background-color: rgba(248, 113, 113, 0.1);
            color: var(--hard);
            border: 1px solid rgba(248, 113, 113, 0.3);
        }
        
        .modal-restrictions {
            background-color: rgba(248, 113, 113, 0.1);
            border-left: 3px solid var(--secondary);
            padding: 15px 20px;
            margin-bottom: 25px;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }
        
        .modal-restrictions h4 {
            color: var(--secondary-light);
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .modal-restrictions ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .modal-restrictions li {
            color: var(--neutral-300);
            font-size: 0.9rem;
            margin-bottom: 6px;
        }
        
        .modal-actions {
            display: flex;
            justify-content: center;
            margin-top: 25px;
        }
        
        /* Active Runs Section */
        .active-runs-container {
            background-color: rgba(84, 99, 255, 0.08);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(84, 99, 255, 0.2);
            position: relative;
        }
        
        .active-runs-title {
            color: var(--primary-light);
            font-size: 1.3rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .active-runs-info {
            color: var(--neutral-400);
            font-size: 0.9rem;
            margin-bottom: 20px;
            font-style: italic;
        }
        
        .active-runs-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .active-run-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--bg-hover);
            padding: 15px 20px;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(84, 99, 255, 0.15);
            transition: all 0.2s ease;
        }
        
        .active-run-item:hover {
            background-color: var(--bg-selected);
            border-color: rgba(84, 99, 255, 0.3);
        }
        
        .run-info {
            flex: 1;
            margin-right: 15px;
        }
        
        .run-story-title {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--neutral-100);
            font-weight: 600;
        }
        
        .run-progress {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .run-stage {
            font-size: 0.85rem;
            color: var(--neutral-400);
        }
        
        .progress-bar {
            height: 8px;
            background-color: var(--neutral-800);
            border-radius: 4px;
            overflow: hidden;
            width: 100%;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            border-radius: 4px;
        }
        
        .run-actions {
            display: flex;
            gap: 12px;
        }
        
        .run-action-button {
            border: none;
            border-radius: var(--radius-sm);
            padding: 10px 15px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .run-action-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--elevation-1);
        }
        
        .continue-run-button {
            background-color: var(--primary);
            color: white;
        }
        
        .continue-run-button:hover {
            background-color: var(--primary-light);
        }
        
        .finish-run-button {
            background-color: var(--secondary);
            color: white;
        }
        
        .finish-run-button:hover {
            background-color: var(--secondary-light);
        }
        
        /* Tooltip message */
        .tooltip-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-50px);
            background-color: var(--bg-card);
            color: var(--neutral-100);
            padding: 12px 24px;
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            z-index: 1000;
            box-shadow: var(--elevation-3);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
            text-align: center;
            border-left: 4px solid var(--primary);
        }
        
        .tooltip-message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        /* Controller support */
        .controller-selected {
            outline: 2px solid var(--secondary-light);
            box-shadow: 0 0 10px var(--secondary-light);
            position: relative;
            z-index: 5;
        }
        
        /* Quest Panel Styles */
        .quest-panel {
            position: fixed;
            right: -320px;
            top: 0;
            width: 320px;
            height: 100vh;
            background: linear-gradient(145deg, var(--bg-card), var(--bg-hover));
            border-left: 2px solid var(--border-light);
            box-shadow: var(--elevation-3);
            transition: right 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .quest-panel.open {
            right: 0;
        }
        
        .quest-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, var(--secondary), var(--primary));
        }
        
        .quest-toggle {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: var(--elevation-2);
            transition: all 0.3s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quest-toggle:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: var(--elevation-3);
        }
        
        .quest-toggle.panel-open {
            right: 340px;
            background: linear-gradient(135deg, var(--neutral-600), var(--neutral-700));
        }
        
        .quest-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-light);
            background: rgba(255, 255, 255, 0.02);
        }
        
        .quest-header h2 {
            font-size: 1.4rem;
            color: var(--neutral-100);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .quest-header p {
            font-size: 0.85rem;
            color: var(--neutral-400);
            margin: 0;
        }
        
        .quest-list {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .quest-item {
            background: var(--bg-hover);
            border-radius: var(--radius-md);
            padding: 15px;
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .quest-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .quest-item:hover {
            background: var(--bg-selected);
            border-color: var(--primary-light);
            transform: translateX(5px);
        }
        
        .quest-item:hover::before {
            opacity: 1;
        }
        
        .quest-item.completed {
            background: rgba(74, 222, 128, 0.1);
            border-color: var(--easy);
        }
        
        .quest-item.completed::before {
            background: var(--easy);
            opacity: 1;
        }
        
        .quest-top {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .quest-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        
        .quest-item.completed .quest-icon {
            background: linear-gradient(135deg, var(--easy), #22c55e);
        }
        
        .quest-info {
            flex: 1;
            min-width: 0;
        }
        
        .quest-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--neutral-100);
            margin-bottom: 2px;
            line-height: 1.2;
        }
        
        .quest-description {
            font-size: 0.8rem;
            color: var(--neutral-400);
            line-height: 1.3;
        }
        
        .quest-progress {
            margin: 10px 0;
        }
        
        .quest-progress-bar {
            width: 100%;
            height: 8px;
            background: var(--neutral-800);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .quest-item.completed .quest-progress-fill {
            background: linear-gradient(to right, var(--easy), #22c55e);
        }
        
        .quest-progress-text {
            font-size: 0.75rem;
            color: var(--neutral-400);
            text-align: center;
        }
        
        .quest-reward {
            background: rgba(255, 189, 0, 0.1);
            border: 1px solid rgba(255, 189, 0, 0.3);
            border-radius: var(--radius-sm);
            padding: 8px 10px;
            margin-top: 10px;
        }
        
        .quest-reward-label {
            font-size: 0.7rem;
            color: var(--legendary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }
        
        .quest-reward-text {
            font-size: 0.8rem;
            color: var(--neutral-200);
            font-weight: 500;
        }
        
        .quest-completion-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px;
            border-radius: var(--radius-md);
            box-shadow: var(--elevation-3);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1100;
            max-width: 350px;
        }
        
        .quest-completion-notification.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .quest-completion-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .quest-completion-icon {
            font-size: 2rem;
            background: rgba(255, 255, 255, 0.2);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quest-completion-text {
            flex: 1;
        }
        
        .quest-completion-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .quest-completion-name {
            font-size: 0.95rem;
            margin-bottom: 3px;
            opacity: 0.9;
        }
        
        .quest-completion-reward {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Quest claiming styles */
        .quest-item.can-claim {
            border: 2px solid var(--legendary);
            box-shadow: 0 0 15px rgba(255, 189, 0, 0.3);
            background: linear-gradient(135deg, var(--bg-hover), rgba(255, 189, 0, 0.05));
        }

        /* Weekly Challenges Styles */
        .weekly-challenges-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 580px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .weekly-challenge-card {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-hover));
            border-radius: var(--radius-md);
            padding: 25px;
            border: 2px solid var(--border-light);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
        }

        .weekly-challenge-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, #ff6b35, #f7931e, #ffbd00);
            opacity: 0.8;
        }

        .weekly-challenge-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.3);
            border-color: #ff6b35;
        }

        .weekly-challenge-card.selected {
            border: 2px solid #ff6b35;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
            background: linear-gradient(135deg, var(--bg-selected), rgba(255, 107, 53, 0.05));
        }

        .weekly-challenge-card.locked {
            filter: grayscale(80%);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .weekly-challenge-card.locked:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-light);
        }

        .weekly-challenge-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .weekly-challenge-icon {
            font-size: 2.5rem;
            margin-right: 15px;
            background: linear-gradient(135deg, #ff6b35, #ffbd00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .weekly-challenge-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--neutral-100);
            margin-bottom: 5px;
        }

        .weekly-challenge-subtitle {
            font-size: 0.95rem;
            color: var(--neutral-400);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .weekly-timer {
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 20px;
            padding: 4px 12px;
            font-size: 0.8rem;
            color: #ff6b35;
            font-weight: 600;
        }

        .weekly-challenge-description {
            font-size: 1.1rem;
            color: var(--neutral-300);
            margin-bottom: 25px;
            line-height: 1.6;
            padding-left: 15px;
            border-left: 3px solid #ff6b35;
        }

        .weekly-challenge-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }

        .weekly-detail-section {
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
            padding: 20px;
            border: 1px solid var(--border-light);
        }

        .weekly-detail-section h4 {
            font-size: 1.2rem;
            color: var(--neutral-100);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weekly-detail-section h4::before {
            font-size: 1.1rem;
        }

        .weekly-detail-section.enemies h4::before {
            content: '🗡️';
        }

        .weekly-detail-section.rewards h4::before {
            content: '🏆';
        }

        .weekly-enemy-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .weekly-enemy-tag {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid rgba(248, 113, 113, 0.3);
            border-radius: 15px;
            padding: 5px 12px;
            font-size: 0.85rem;
            color: var(--hard);
            font-weight: 500;
        }

        .weekly-modifiers {
            background: rgba(255, 189, 0, 0.08);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 189, 0, 0.2);
        }

        .weekly-modifiers h4 {
            font-size: 1.2rem;
            color: var(--legendary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weekly-modifiers h4::before {
            content: '⚡';
            font-size: 1.1rem;
        }

        .weekly-modifier-item {
            background: rgba(255, 189, 0, 0.1);
            border-left: 3px solid var(--legendary);
            padding: 12px 15px;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            font-size: 1rem;
            color: var(--neutral-200);
            font-weight: 500;
        }

        .weekly-rewards {
            background: rgba(74, 222, 128, 0.08);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(74, 222, 128, 0.2);
        }

        .weekly-rewards h4 {
            font-size: 1.2rem;
            color: var(--easy);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weekly-rewards h4::before {
            content: '🎁';
            font-size: 1.1rem;
        }

        .weekly-reward-item {
            background: rgba(74, 222, 128, 0.1);
            border-left: 3px solid var(--easy);
            padding: 12px 15px;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            font-size: 1rem;
            color: var(--neutral-200);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .weekly-reward-icon {
            font-size: 1.2rem;
        }

        .weekly-challenge-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 20px;
            border-top: 1px solid var(--border-light);
        }

        .weekly-difficulty-badge {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .weekly-team-size {
            color: var(--neutral-300);
            font-size: 0.95rem;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .weekly-challenge-details {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .weekly-challenge-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .weekly-challenge-icon {
                font-size: 2rem;
                margin-right: 0;
            }
        }

        .quest-item.can-claim::before {
            background: var(--legendary);
            opacity: 1;
        }

        .quest-claim-section {
            margin-top: 15px;
            text-align: center;
        }

        .quest-claim-button {
            background: linear-gradient(135deg, var(--legendary), #ff8c00);
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Montserrat', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px rgba(255, 189, 0, 0.3);
        }

        .quest-claim-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 189, 0, 0.4);
            background: linear-gradient(135deg, #ff8c00, var(--legendary));
        }

        .quest-claim-button:active {
            transform: translateY(0);
        }

        /* Quest claim notification */
        .quest-claim-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--legendary), #ff8c00);
            color: white;
            padding: 20px;
            border-radius: var(--radius-md);
            box-shadow: var(--elevation-3);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1100;
            max-width: 350px;
        }

        .quest-claim-notification.show {
            transform: translateX(0);
            opacity: 1;
        }

        .quest-claim-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .quest-claim-icon {
            font-size: 2rem;
            background: rgba(255, 255, 255, 0.2);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: claimPulse 2s ease-in-out infinite;
        }

        @keyframes claimPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .quest-claim-text {
            flex: 1;
        }

        .quest-claim-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .quest-claim-name {
            font-size: 0.95rem;
            margin-bottom: 3px;
            opacity: 0.9;
        }

        .quest-claim-reward {
            font-size: 0.8rem;
            opacity: 0.8;
            font-weight: 600;
        }

        /* Weekly Challenges Styles */
        .weekly-challenges-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 580px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .weekly-challenge-card {
            background: linear-gradient(135deg, var(--bg-card), var(--bg-hover));
            border-radius: var(--radius-md);
            padding: 25px;
            border: 2px solid var(--border-light);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
        }

        .weekly-challenge-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, #ff6b35, #f7931e, #ffbd00);
            opacity: 0.8;
        }

        .weekly-challenge-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.3);
            border-color: #ff6b35;
        }

        .weekly-challenge-card.selected {
            border: 2px solid #ff6b35;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
            background: linear-gradient(135deg, var(--bg-selected), rgba(255, 107, 53, 0.05));
        }

        .weekly-challenge-card.locked {
            filter: grayscale(80%);
            opacity: 0.6;
            cursor: not-allowed;
        }

        .weekly-challenge-card.locked:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-light);
        }

        .weekly-challenge-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .weekly-challenge-icon {
            font-size: 2.5rem;
            margin-right: 15px;
            background: linear-gradient(135deg, #ff6b35, #ffbd00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .weekly-challenge-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--neutral-100);
            margin-bottom: 5px;
        }

        .weekly-challenge-subtitle {
            font-size: 0.95rem;
            color: var(--neutral-400);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .weekly-timer {
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid rgba(255, 107, 53, 0.3);
            border-radius: 20px;
            padding: 4px 12px;
            font-size: 0.8rem;
            color: #ff6b35;
            font-weight: 600;
        }

        .weekly-challenge-description {
            font-size: 1.1rem;
            color: var(--neutral-300);
            margin-bottom: 25px;
            line-height: 1.6;
            padding-left: 15px;
            border-left: 3px solid #ff6b35;
        }

        .weekly-challenge-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }

        .weekly-detail-section {
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
            padding: 20px;
            border: 1px solid var(--border-light);
        }

        .weekly-detail-section h4 {
            font-size: 1.2rem;
            color: var(--neutral-100);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weekly-detail-section h4::before {
            font-size: 1.1rem;
        }

        .weekly-detail-section.enemies h4::before {
            content: '🗡️';
        }

        .weekly-detail-section.rewards h4::before {
            content: '🏆';
        }

        .weekly-enemy-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .weekly-enemy-tag {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid rgba(248, 113, 113, 0.3);
            border-radius: 15px;
            padding: 5px 12px;
            font-size: 0.85rem;
            color: var(--hard);
            font-weight: 500;
        }

        .weekly-modifiers {
            background: rgba(255, 189, 0, 0.08);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 189, 0, 0.2);
        }

        .weekly-modifiers h4 {
            font-size: 1.2rem;
            color: var(--legendary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weekly-modifiers h4::before {
            content: '⚡';
            font-size: 1.1rem;
        }

        .weekly-modifier-item {
            background: rgba(255, 189, 0, 0.1);
            border-left: 3px solid var(--legendary);
            padding: 12px 15px;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            font-size: 1rem;
            color: var(--neutral-200);
            font-weight: 500;
        }

        .weekly-rewards {
            background: rgba(74, 222, 128, 0.08);
            border-radius: var(--radius-sm);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(74, 222, 128, 0.2);
        }

        .weekly-rewards h4 {
            font-size: 1.2rem;
            color: var(--easy);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .weekly-rewards h4::before {
            content: '🎁';
            font-size: 1.1rem;
        }

        .weekly-reward-item {
            background: rgba(74, 222, 128, 0.1);
            border-left: 3px solid var(--easy);
            padding: 12px 15px;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            font-size: 1rem;
            color: var(--neutral-200);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .weekly-reward-icon {
            font-size: 1.2rem;
        }

        .weekly-challenge-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 20px;
            border-top: 1px solid var(--border-light);
        }

        .weekly-difficulty-badge {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .weekly-team-size {
            color: var(--neutral-300);
            font-size: 0.95rem;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .weekly-challenge-details {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .weekly-challenge-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .weekly-challenge-icon {
                font-size: 2rem;
                margin-right: 0;
            }
        }
        
        /* Responsive styling */
        @media (max-width: 1200px) {
            .character-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
            
            .stage-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            }
            
            .quest-panel {
                width: 300px;
                right: -300px;
            }
            
            .quest-toggle.panel-open {
                right: 320px;
            }
        }
        
        @media (max-width: 992px) {
            .content-wrapper {
                flex-direction: column;
            }
            
            .selector-panel {
                max-height: 600px;
            }
            
            .tab-content, .character-grid {
                max-height: 480px;
            }
            
            .team-slots {
                flex-wrap: wrap;
            }
        }
        
        @media (max-width: 768px) {
            .app-header h1 {
                font-size: 2rem;
            }
            
            .app-header h1::before,
            .app-header h1::after {
                width: 40px;
            }
            
            .panel-header h2 {
                font-size: 1.3rem;
            }
            
            .action-button {
                min-width: 120px;
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            
            .team-slot {
                width: 60px;
                height: 60px;
            }
            
            .quest-panel {
                width: 280px;
                right: -280px;
            }
            
            .quest-toggle.panel-open {
                right: 300px;
            }
            
            .quest-completion-notification {
                max-width: 280px;
                right: 10px;
                top: 10px;
            }
        }
        
        @media (max-width: 576px) {
            .app-container {
                padding: 10px;
            }
            
            .app-header h1 {
                font-size: 1.5rem;
            }
            
            .tabs {
                justify-content: space-between;
            }
            
            .tab-button {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .character-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
            }
            
            .stage-grid {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 10px;
            }
            
            .character-name {
                font-size: 0.85rem;
            }
            
            .team-slots {
                gap: 12px;
            }
            
            .team-slot {
                width: 50px;
                height: 50px;
            }
            
            .action-buttons {
                gap: 12px;
            }
            
            .action-button {
                min-width: auto;
                padding: 10px 15px;
                font-size: 0.8rem;
            }
            
            .quest-panel {
                width: 100vw;
                right: -100vw;
                border-left: none;
                border-top: 2px solid var(--border-light);
            }
            
            .quest-toggle {
                position: fixed;
                bottom: 20px;
                right: 20px;
                top: auto;
                transform: none;
                z-index: 1001;
            }
            
            .quest-toggle.panel-open {
                right: 20px;
                bottom: 20px;
            }
            
            .quest-completion-notification {
                max-width: 90vw;
                right: 5%;
                left: 5%;
                top: 10px;
            }
        }

        /* Quest Progress Panel */
        .quest-progress-panel {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-light);
            box-shadow: var(--elevation-1);
        }

        .quest-progress-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quest-progress-header h3 {
            margin: 0;
            color: var(--primary-light);
            font-size: 1.2rem;
        }

        .quest-item {
            background: var(--bg-hover);
            border-radius: var(--radius-sm);
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid var(--primary);
        }

        .quest-item.completed {
            border-left-color: var(--common);
            background: rgba(107, 221, 170, 0.1);
        }

        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .quest-name {
            font-weight: 600;
            color: var(--neutral-100);
        }

        .quest-icon {
            font-size: 1.2rem;
        }

        .quest-description {
            font-size: 0.9rem;
            color: var(--neutral-400);
            margin-bottom: 8px;
        }

        .quest-progress-bar {
            background: var(--neutral-700);
            border-radius: 10px;
            height: 6px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .quest-progress-fill {
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            height: 100%;
            transition: width 0.3s ease;
        }

        .quest-progress-fill.completed {
            background: linear-gradient(to right, var(--common), #7dd3fc);
        }

        .quest-progress-text {
            font-size: 0.8rem;
            color: var(--neutral-400);
            text-align: right;
        }

        .quest-claim-button {
            background: var(--common);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            margin-top: 8px;
            transition: all 0.2s ease;
        }

        .quest-claim-button:hover {
            background: #5fb584;
            transform: translateY(-1px);
        }

        .quest-claim-button:disabled {
            background: var(--neutral-600);
            cursor: not-allowed;
            transform: none;
        }

        .quest-add-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            margin-top: 10px;
            transition: all 0.2s ease;
        }

        .quest-add-button:hover {
            background: var(--primary-light);
            transform: translateY(-1px);
        }

        /* Overrides for Character Selector */
        body { height: auto !important; overflow-y: auto !important; }
        /* Ensure quest panel itself can scroll if too tall */
        .quests-panel { max-height: 85vh; overflow-y: auto; }
        /* Hide completed quests as an extra safeguard */
        .quests-panel .quest-item.completed { display: none; }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header Section -->
        <header class="app-header">
            <h1></h1>
            <div class="header-buttons">
                <button class="nav-button" onclick="window.location.href='skin-shop.html'">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 7h-3V6a4 4 0 0 0-8 0v1H5a1 1 0 0 0-1 1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8a1 1 0 0 0-1-1zM10 6a2 2 0 0 1 4 0v1h-4V6zm8 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v10z"/>
                    </svg>
                    Skin Shop
                </button>
                <button class="nav-button" onclick="window.location.href='skin-selector.html'">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L15 1H5C3.89 1 3 1.89 3 3V7H1V9H3V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V9H21ZM19 19H5V9H19V19Z"/>
                    </svg>
                    Skin Selector
                </button>
                <button class="changelog-button" onclick="showChangelog()">
                    <svg class="changelog-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                    </svg>
                    What's New
                    <span class="version-badge">v0.2</span>
                </button>
                <button class="nav-button" onclick="showOldChangelog()">
                    <svg class="nav-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"/>
                    </svg>
                    v0.1.1
                </button>
            </div>
        </header>

        <!-- New Quest Panel Toggle -->
        <button class="quest-panel-toggle" id="quest-panel-toggle" title="Toggle Quest Panel (SHIFT key)">
            🎯 Quests
        </button>

        <!-- New Quests Panel (managed by quest-ui-manager.js) -->
        <div class="quests-panel" id="quests-panel" style="display: none;">
            <div class="quests-panel-header">
                <h3>🎯 Character Quests</h3>
                <button class="toggle-quests-button" id="toggle-quests-button">▼</button>
            </div>
            <div class="quests-panel-content" id="quests-panel-content">
                <div class="quests-loading" id="quests-loading">
                    <p>Loading quests...</p>
                </div>
                <div class="quests-list" id="quests-list"></div>
                <div class="quests-empty" id="quests-empty" style="display: none;">
                    <p>No active quests for selected character</p>
                </div>
            </div>
        </div>
        
        <!-- Quest Toggle Button -->
        <!-- Legacy quest-toggle button disabled -->
        <!--
        <button class="quest-toggle" id="quest-toggle" title="Toggle Quest Journal">
            📜
        </button>
        -->
        
        <main class="content-wrapper">
            <!-- Story/Stage Selection Panel -->
            <section class="selector-panel">
                <div class="panel-header">
                    <h2>Select a Story or Stage</h2>
                    <p>Choose your next challenge, hero</p>
                </div>
                
                <div class="tabs">
                    <button class="tab-button active" data-tab="story-tab">Story Mode</button>
                    <button class="tab-button" data-tab="stage-tab">Single Stages</button>
                    <button class="tab-button" data-tab="weekly-tab">Weekly Challenges</button>
                </div>
                
                <div class="tab-content active" id="story-tab">
                    <div id="story-stage-grid" class="stage-grid"></div>
                </div>
                
                <div class="tab-content" id="stage-tab">
                    <div id="single-stage-grid" class="stage-grid"></div>
                </div>
                
                <div class="tab-content" id="weekly-tab">
                    <div id="weekly-challenges-grid" class="weekly-challenges-grid"></div>
                </div>
            </section>
            
            <!-- Character Selection Panel -->
            <section class="selector-panel">
                <div class="panel-header">
                    <h2>Select Your Team</h2>
                    <p id="team-restriction-text">Choose your heroes carefully</p>
                </div>
                
                <div class="filter-container">
                    <div class="tag-filters" id="tag-filters">
                        <!-- Tag filter buttons will be populated here -->
                    </div>
                </div>
                
                <div id="character-grid" class="character-grid">
                    <!-- Character cards will be loaded here -->
                </div>
            </section>
        </main>
        
        <!-- Team Preview Section -->
        <section class="team-preview">
            <h2 id="selected-team-title">Your Team</h2>
            <div class="team-slots" id="team-slots">
                <!-- Slots will be dynamically generated -->
            </div>
            
            <div class="action-buttons">
                <button id="back-button" class="action-button back-button">Back</button>
                <button id="start-button" class="action-button start-button">Start Battle</button>
            </div>
        </section>
    </div>
    
    <!-- Stage Detail Modal -->
    <div class="modal" id="stage-detail-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <div class="stage-detail-content" id="stage-detail-content">
                <!-- Stage details will be populated here -->
            </div>
        </div>
    </div>

    <!-- Firebase JS SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-database-compat.js"></script>

        <!-- Firebase Config -->
    <script src="js/firebase-config.js"></script>
    
    <!-- Character Classes (required for XP calculations) -->
    <script src="js/raid-game/character.js"></script>
    
    <!-- Character XP Manager -->
    <script src="js/raid-game/character-xp-manager.js"></script>
    
    <!-- Talent Manager -->
    <script src="js/raid-game/talent-manager.js"></script>
    
    <!-- Quest Manager -->
    <script src="js/raid-game/quest-manager.js"></script>
    
    <!-- New Quest UI Manager -->
    <script src="js/raid-game/quest-ui-manager.js"></script>
    
    <!-- Controller Support -->
    <script src="js/character-selector-controller.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            let selectedCharacters = [];
            let selectedStory = null;
            let selectedStage = null;
            let selectedWeeklyChallenge = null;
            let allCharacters = [];
            let maxTeamSize = 4;
            let minTeamSize = 1;
            let stageRegistry = {};
            let allTags = new Set();
            let activeTagFilter = null;
            let allStories = [];
            let allStages = [];
            let allWeeklyChallenges = [];
            let ownedCharacters = [];
            let ownedStories = [];
            let ownedStages = [];
            let isLoadingUserData = true;
            let activeRuns = [];
            let currentSelectionMode = 'story';
            let characterXPManager = null;
            let currentUserId = null; // Store current user ID globally

            // UI Element Variables
            let characterGrid, storyContainer, stageContainer, weeklyChallengesContainer, teamSlotsContainer,
                selectedTeamTitle, startButton, backButton, tagFiltersContainer,
                teamRestrictionText, questPanel, questToggle, questList;
            
            // Tab Switching Logic
            function setupTabSwitching() {
                const tabButtons = document.querySelectorAll('.tab-button');
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Remove active class from all buttons and contents
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                        
                        // Add active class to clicked button and corresponding content
                        button.classList.add('active');
                        const tabId = button.getAttribute('data-tab');
                        document.getElementById(tabId).classList.add('active');
                        
                        // Set current selection mode
                        if (tabId === 'story-tab') {
                            currentSelectionMode = 'story';
                        } else if (tabId === 'stage-tab') {
                            currentSelectionMode = 'stage';
                        } else if (tabId === 'weekly-tab') {
                            currentSelectionMode = 'weekly';
                        }
                        
                        // Reset selections when switching tabs
                        if (currentSelectionMode === 'story') {
                            selectedStage = null;
                            // Update UI based on story requirements
                            if (selectedStory) {
                                const reqs = selectedStory.requirements || {};
                                const newMaxSize = reqs.teamSize?.max ?? 4;
                                const newMinSize = reqs.teamSize?.min ?? 1;
                                updateTeamSizeUI(newMaxSize, newMinSize);
                            } else {
                                updateTeamSizeUI(4, 1); // Default
                            }
                        } else if (currentSelectionMode === 'stage') {
                            selectedStory = null;
                            selectedWeeklyChallenge = null;
                            // Update UI based on stage requirements
                            if (selectedStage && selectedStage.id === '5v5_blazing_school_day') {
                                updateTeamSizeUI(5, 1); // Special case for 5v5 stage
                            } else {
                                updateTeamSizeUI(4, 1); // Default
                            }
                        } else if (currentSelectionMode === 'weekly') {
                            selectedStory = null;
                            selectedStage = null;
                            // Update UI based on weekly challenge requirements
                            if (selectedWeeklyChallenge) {
                                updateTeamSizeUI(selectedWeeklyChallenge.teamSize, 1);
                            } else {
                                updateTeamSizeUI(5, 1); // Default for weekly challenges
                            }
                        }
                        
                        clearSelections();
                        applyStoryRestrictions();
                        updateTeamRestrictionText();
                        updateStartButtonState();
                    });
                });
            }
            
            function clearSelections() {
                // Clear selected cards and update UI
                document.querySelectorAll('.stage-card.selected, .story-container.selected, .weekly-challenge-card.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedCharacters = [];
                updateTeamSlotsUI();
            }

            // Function to convert image path
            function getCharacterIconPath(character) {
                // The paths in character-registry.json are already correct
                return character.image || null;
            }

            try {
                // Firebase Auth Check
                firebaseAuth.onAuthStateChanged(async (user) => {
                    if (user) {
                        console.log("User logged in:", user.uid);
                        const userId = user.uid;
                        currentUserId = userId; // Set global user ID
                        // Fetch user data (including owned characters)
                        try {
                            const snapshot = await firebaseDatabase.ref(`users/${userId}/ownedCharacters`).once('value');
                            if (snapshot.exists()) {
                                // Firebase stores objects, convert keys to array if needed, or assume it's an array
                                const ownedData = snapshot.val();
                                if (Array.isArray(ownedData)) {
                                    ownedCharacters = ownedData;
                                } else if (typeof ownedData === 'object') {
                                    // Handle cases where Firebase might store it as { 0: "id1", 1: "id2" }
                                    ownedCharacters = Object.values(ownedData);
                                } else {
                                    console.warn("Owned characters data is not an array or object:", ownedData);
                                    ownedCharacters = []; // Fallback to empty
                                }
                                console.log("Fetched owned characters:", ownedCharacters);
                            } else {
                                console.log("No owned characters found for user, using defaults from character registry.");
                                ownedCharacters = [];
                            }
                            
                            // Also fetch unlocked RAID characters from tutorial/story rewards
                            const unlockedRAIDSnapshot = await firebaseDatabase.ref(`users/${userId}/UnlockedRAIDCharacters`).once('value');
                            if (unlockedRAIDSnapshot.exists()) {
                                const unlockedData = unlockedRAIDSnapshot.val();
                                const unlockedCharacterIds = Object.keys(unlockedData);
                                console.log("Fetched unlocked RAID characters:", unlockedCharacterIds);
                                
                                // Merge with owned characters, avoiding duplicates
                                ownedCharacters = [...new Set([...ownedCharacters, ...unlockedCharacterIds])];
                            } else {
                                console.log("No unlocked RAID characters found for user.");
                            }
                            
                            // Always include characters that are marked as playerunlocked in the registry
                            const defaultUnlockedCharacters = allCharacters.filter(c => c.playerunlocked).map(c => c.id);
                            ownedCharacters = [...new Set([...ownedCharacters, ...defaultUnlockedCharacters])];
                            console.log("Final owned characters (including defaults):", ownedCharacters);
                            
                            // Check for owned stories
                            const ownedStoriesSnapshot = await firebaseDatabase.ref(`users/${userId}/ownedStories`).once('value');
                            if (ownedStoriesSnapshot.exists()) {
                                const ownedData = ownedStoriesSnapshot.val();
                                if (Array.isArray(ownedData)) {
                                    ownedStories = ownedData;
                                } else if (typeof ownedData === 'object') {
                                    ownedStories = Object.values(ownedData);
                                } else {
                                    console.warn("Owned stories data is not an array or object:", ownedData);
                                    ownedStories = [];
                                }
                                console.log("Fetched owned stories:", ownedStories);
                            } else {
                                console.log("No owned stories found for user, using defaults from story registry.");
                                // Use playerunlocked from stories as defaults
                                ownedStories = allStories.filter(s => s.playerunlocked).map(s => getStoryId(s));
                            }
                            
                                        // Check global story availability settings (for remote control)
            try {
                const globalStoryAvailabilitySnapshot = await firebaseDatabase.ref('globalSettings/storyAvailability').once('value');
                if (globalStoryAvailabilitySnapshot.exists()) {
                    const globalSettings = globalStoryAvailabilitySnapshot.val();
                    console.log('Global story availability settings:', globalSettings);

                    // Apply global settings to user's owned stories
                    Object.entries(globalSettings).forEach(([storyId, isEnabled]) => {
                        if (isEnabled === true) {
                            // Story is globally enabled - add it to user's owned stories if not already there
                            if (!ownedStories.includes(storyId)) {
                                ownedStories.push(storyId);
                                console.log(`[Global Setting] Added ${storyId} to user stories (globally enabled)`);
                            }
                        } else if (isEnabled === false) {
                            // Story is globally disabled - remove it from user's owned stories
                            const index = ownedStories.indexOf(storyId);
                            if (index > -1) {
                                ownedStories.splice(index, 1);
                                console.log(`[Global Setting] Removed ${storyId} from user stories (globally disabled)`);
                            }
                        }
                        // If null/undefined, use the default behavior (local playerunlocked setting)
                    });
                }
            } catch (error) {
                console.error('Error fetching global story availability settings:', error);
            }
                            
                            // Check for owned stages
                            const ownedStagesSnapshot = await firebaseDatabase.ref(`users/${userId}/ownedStages`).once('value');
                            if (ownedStagesSnapshot.exists()) {
                                const ownedData = ownedStagesSnapshot.val();
                                if (Array.isArray(ownedData)) {
                                    ownedStages = ownedData;
                                } else if (typeof ownedData === 'object') {
                                    ownedStages = Object.values(ownedData);
                                } else {
                                    console.warn("Owned stages data is not an array or object:", ownedData);
                                    ownedStages = [];
                                }
                                console.log("Fetched owned stages:", ownedStages);
                            } else {
                                console.log("No owned stages found for user, using defaults from stage registry.");
                                // Use playerunlocked from stages as defaults
                                ownedStages = allStages.filter(s => s.playerunlocked).map(s => s.id);
                            }
                            
                            // Check for active story runs
                            const storyProgressSnapshot = await firebaseDatabase.ref(`users/${userId}/storyProgress`).once('value');
                            if (storyProgressSnapshot.exists()) {
                                const allProgress = storyProgressSnapshot.val();
                                console.log("Found story progress data:", allProgress);
                                
                                // Convert to array of { storyId, progress } objects
                                activeRuns = Object.entries(allProgress).map(([storyId, progress]) => ({
                                    storyId,
                                    progress
                                }));
                                
                                if (activeRuns.length > 0) {
                                    console.log(`Found ${activeRuns.length} active story runs`);
                                    displayActiveRuns(activeRuns);
                                }
                            } else {
                                console.log("No active story runs found");
                            }
                            
                        } catch (error) {
                            console.error("Error fetching user data:", error);
                            showTooltip("Error loading your user data.");
                            // Fallback: Use defaults from registries
                            ownedCharacters = allCharacters.filter(c => c.playerunlocked).map(c => c.id);
                            ownedStories = allStories.filter(s => s.playerunlocked).map(s => getStoryId(s));
                            ownedStages = allStages.filter(s => s.playerunlocked).map(s => s.id);
                        }
                        
                        // Initialize talent points for all characters (first time setup)
                        try {
                            if (typeof window.talentManager !== 'undefined' && window.talentManager.initializeAllCharacterTalentPoints) {
                                await window.talentManager.initializeAllCharacterTalentPoints(userId);
                            } else {
                                console.log("TalentManager not available, will initialize talent points later");
                            }
                        } catch (error) {
                            console.error("Error initializing talent points:", error);
                        }
                        
                        // Initialize character XP manager
                        try {
                            if (typeof window.characterXPManager !== 'undefined') {
                                characterXPManager = window.characterXPManager;
                                if (!characterXPManager.initialized) {
                                    await characterXPManager.initialize();
                                }
                                console.log('[CharacterSelector] Using global CharacterXPManager');
                            }
                        } catch (error) {
                            console.error("Error initializing character XP manager:", error);
                        }
                        
                        // Initialize quest manager
                        try {
                            if (typeof window.questManager !== 'undefined') {
                                await window.questManager.initialize();
                                console.log('[CharacterSelector] Quest manager initialized');
                                
                                // Check for 'complete_to_the_hell_we_go_story' quest completion
                                console.log('[CharacterSelector] About to call checkAndCompleteHellStoryQuest...');
                                console.log('[CharacterSelector] Current userId:', userId);
                                console.log('[CharacterSelector] checkAndCompleteHellStoryQuest function exists:', typeof checkAndCompleteHellStoryQuest);
                                
                                try {
                                    await checkAndCompleteHellStoryQuest(userId);
                                    console.log('[CharacterSelector] checkAndCompleteHellStoryQuest completed');
                                } catch (hellQuestError) {
                                    console.error('[CharacterSelector] Error in checkAndCompleteHellStoryQuest:', hellQuestError);
                                }
                            } else {
                                console.log('[CharacterSelector] Quest manager not available, skipping hell story quest check');
                            }
                        } catch (error) {
                            console.error("Error initializing quest manager:", error);
                        }
                        
                        isLoadingUserData = false;
                        // Re-populate/update grids now that user data is loaded
                        populateCharacterGrid(allCharacters);
                        populateStoryGrid(allStories);
                        populateStageGrid(allStages);
                        
                        // Load XP data for character cards
                        await updateAllCharacterXPDisplays();
                        
                        // Load talent point indicators for character cards
                        await updateAllTalentPointIndicators();
                    } else {
                        console.log("User not logged in. Redirecting to index.html");
                        window.location.href = 'index.html';
                    }
                });

                const [characterData, storiesData, stageRegistryData, singleStagesData] = await Promise.all([
                    fetch('js/raid-game/character-registry.json').then(response => response.ok ? response.json() : Promise.reject('Failed to load characters')),
                    fetch('stories.json').then(response => response.ok ? response.json() : Promise.reject('Failed to load stories')),
                    fetch('js/raid-game/stage-registry.json').then(response => response.ok ? response.json() : Promise.reject('Failed to load stage registry')),
                    fetch('single-stages.json').then(response => response.ok ? response.json() : Promise.reject('Failed to load single stages'))
                ]);

                allStories = storiesData;
                stageRegistry = stageRegistryData;
                
                // Extract standalone stages (non-story stages) and filter out hidden ones
                allStages = stageRegistry.stages
                    .filter(stage => 
                        (stage.type === 'single' || stage.type === 'challenge') && 
                        !stage.isHidden
                    );

                // Add single stages from single-stages.json
                if (singleStagesData && Array.isArray(singleStagesData)) {
                    allStages = [...allStages, ...singleStagesData];
                    console.log(`Added ${singleStagesData.length} single stages from single-stages.json`);
                }
                
                allCharacters = characterData.characters
                    .filter(char => !char.isHidden) // Filter out hidden characters
                    .map(char => ({
                        ...char,
                        // Use the id from the registry directly, don't generate from name
                        id: char.id
                    }));

                // Extract all tags from characters
                allCharacters.forEach(char => {
                    if (char.tags && Array.isArray(char.tags)) {
                        char.tags.forEach(tag => allTags.add(tag));
                    }
                });

                // Initialize weekly challenges – Healing Forbidden replaces old Siegfried challenge
                allWeeklyChallenges = [
                    {
                        id: 'healing_forbidden_challenge',
                        name: 'Healing Forbidden Challenge',
                        description: 'No healing magic can save you! Defeat Farmer Raiden, Schoolgirl Elphelt, Farmer Nina and Schoolgirl Ayane with a team of only 3 heroes.',
                        difficulty: 7,
                        teamSize: 3,
                        enemies: ['farmer_raiden', 'schoolgirl_elphelt', 'farmer_nina', 'schoolgirl_ayane'],
                        modifiers: [{
                            id: 'healing_disabled',
                            name: 'Healing Disabled',
                            description: 'All healing is blocked for the entire battle.'
                        }],
                        rewards: [{
                            type: 'character',
                            id: 'zoey',
                            name: 'Zoey',
                            icon: '🍓'
                        }],
                        timeRemaining: 'Resets in 3 days, 12 hours',
                        isAvailable: true
                    }
                ];

                // Assign UI Elements
                characterGrid = document.getElementById('character-grid');
                storyContainer = document.getElementById('story-stage-grid');
                stageContainer = document.getElementById('single-stage-grid');
                weeklyChallengesContainer = document.getElementById('weekly-challenges-grid');
                teamSlotsContainer = document.getElementById('team-slots');
                selectedTeamTitle = document.getElementById('selected-team-title');
                startButton = document.getElementById('start-button');
                backButton = document.getElementById('back-button');
                tagFiltersContainer = document.getElementById('tag-filters');
                teamRestrictionText = document.getElementById('team-restriction-text');
                questPanel = document.getElementById('quest-panel');
                // If legacy quest panel is absent, create a harmless stub to avoid runtime errors
                if (!questPanel) {
                    questPanel = document.createElement('div');
                }
                questToggle = document.getElementById('quest-toggle');
                questList = document.getElementById('quest-list');

                // Initial Population
                setupTabSwitching();
                // setupQuestPanel(); // Legacy quest panel disabled – replaced by QuestUIManager
                updateTeamSizeUI(maxTeamSize, minTeamSize);
                populateTagFilters(Array.from(allTags));
                populateCharacterGrid(allCharacters);
                populateStoryGrid(allStories);
                populateStageGrid(allStages);
                populateWeeklyChallenges(allWeeklyChallenges);
                
                // Add window focus listener to refresh talent point indicators when returning from talents page
                window.addEventListener('focus', () => {
                    if (currentUserId) {
                        updateAllTalentPointIndicators().catch(error => {
                            console.error('Error updating talent point indicators on window focus:', error);
                        });
                    }
                });

            } catch (error) {
                console.error("Error loading initial data:", error);
                document.querySelector('.app-container').innerHTML = `
                    <div class="error-screen">
                        <h1>Error</h1>
                        <p>Could not load game data. Please try again later.</p>
                        <p class="error-details">Details: ${error}</p>
                        <button onclick="location.reload()" class="action-button start-button">Retry</button>
                    </div>`;
                return;
            }

            function populateCharacterGrid(charactersToDisplay) {
                characterGrid.innerHTML = '';
                
                // Sort characters so unlocked ones appear first
                const sortedCharacters = [...charactersToDisplay].sort((a, b) => {
                    const aIsOwned = ownedCharacters.includes(a.id);
                    const bIsOwned = ownedCharacters.includes(b.id);
                    
                    // If ownership status is different, prioritize owned characters
                    if (aIsOwned !== bIsOwned) {
                        return bIsOwned - aIsOwned; // Owned characters (true) come first
                    }
                    
                    // If ownership status is same, maintain original order (alphabetical by name)
                    return a.name.localeCompare(b.name);
                });
                
                sortedCharacters.forEach(character => {
                    const card = createCharacterCard(character);
                    characterGrid.appendChild(card);
                });
                applyStoryRestrictions();
                
                // Update talent point indicators after grid population
                if (currentUserId) {
                    updateAllTalentPointIndicators().catch(error => {
                        console.error('Error updating talent point indicators in populateCharacterGrid:', error);
                    });
                }
            }

            // Talent Points Management Functions
            async function getUnusedTalentPoints(characterId, userId) {
                if (!userId) {
                    console.warn('No user ID provided for talent points check');
                    return 0;
                }

                try {
                    // Get total talent points for the character
                    const totalPointsSnapshot = await firebaseDatabase.ref(`users/${userId}/characterTalentPoints/${characterId}`).once('value');
                    const totalPoints = totalPointsSnapshot.val() || 0;

                    // Get selected talents for the character (stored as boolean values)
                    const characterTalentsSnapshot = await firebaseDatabase.ref(`users/${userId}/characterTalents/${characterId}`).once('value');
                    const characterTalents = characterTalentsSnapshot.val() || {};

                    // Also check selectedTalents path as fallback (for characters that use rank-based talents)
                    const selectedTalentsSnapshot = await firebaseDatabase.ref(`users/${userId}/selectedTalents/${characterId}`).once('value');
                    const selectedTalents = selectedTalentsSnapshot.val() || {};

                    // Calculate used points
                    let usedPoints = 0;
                    
                    // Count boolean talents (each true talent = 1 point used)
                    for (const talentId in characterTalents) {
                        if (characterTalents[talentId] === true) {
                            usedPoints += 1;
                        }
                    }
                    
                    // Count rank-based talents (each rank = 1 point used)
                    for (const talentId in selectedTalents) {
                        usedPoints += selectedTalents[talentId] || 0;
                    }

                    const unusedPoints = Math.max(0, totalPoints - usedPoints);
                    console.log(`[TalentPoints] ${characterId}: Total=${totalPoints}, Used=${usedPoints}, Unused=${unusedPoints}`);
                    return unusedPoints;
                } catch (error) {
                    console.error(`Error getting unused talent points for ${characterId}:`, error);
                    return 0;
                }
            }

            async function updateAllTalentPointIndicators() {
                if (!currentUserId) {
                    console.log('No user ID available for talent point indicators');
                    return;
                }

                const characterCards = document.querySelectorAll('.character-card');
                
                for (const card of characterCards) {
                    const characterId = card.dataset.id;
                    const indicator = card.querySelector('.talent-points-indicator');
                    
                    if (!indicator) continue; // Skip if no indicator (locked characters)

                    try {
                        const unusedPoints = await getUnusedTalentPoints(characterId, currentUserId);
                        
                        indicator.textContent = unusedPoints;
                        indicator.dataset.points = unusedPoints;
                        
                        if (unusedPoints > 0) {
                            indicator.classList.remove('hidden');
                            indicator.title = `${unusedPoints} unused talent point${unusedPoints > 1 ? 's' : ''}`;
                        } else {
                            indicator.classList.add('hidden');
                        }
                    } catch (error) {
                        console.error(`Error updating talent point indicator for ${characterId}:`, error);
                        indicator.classList.add('hidden');
                    }
                }
            }

            /**
             * Update all character cards with XP and level data
             */
            async function updateAllCharacterXPDisplays() {
                if (!characterXPManager) {
                    console.warn('[CharacterSelector] XP Manager not available');
                    return;
                }

                const characterCards = document.querySelectorAll('.character-card');
                const xpPromises = [];

                characterCards.forEach(card => {
                    const characterId = card.dataset.id;
                    const isOwned = ownedCharacters.includes(characterId);
                    
                    if (isOwned) {
                        const promise = characterXPManager.getCharacterXP(characterId)
                            .then(xpData => {
                                // Update level display
                                const levelDisplay = card.querySelector('.character-level');
                                if (levelDisplay) {
                                    levelDisplay.textContent = `Lv.${xpData.level}`;
                                }

                                // Update XP bar and text
                                const xpFill = card.querySelector('.xp-fill-small');
                                const xpText = card.querySelector('.xp-text-small');
                                
                                if (xpFill && xpText) {
                                    const xpProgress = (xpData.currentXP / xpData.xpForNextLevel) * 100;
                                    xpFill.style.width = `${Math.min(xpProgress, 100)}%`;
                                    xpText.textContent = `${xpData.currentXP} / ${xpData.xpForNextLevel} XP`;
                                }
                            })
                            .catch(error => {
                                console.error(`Error loading XP for character ${characterId}:`, error);
                            });
                        
                        xpPromises.push(promise);
                    }
                });

                try {
                    await Promise.all(xpPromises);
                    console.log('[CharacterSelector] Updated XP displays for all owned characters');
                } catch (error) {
                    console.error('[CharacterSelector] Error updating XP displays:', error);
                }
            }

            function displayActiveRuns(runs) {
                // Create a container for active runs at the top of the story selection
                const activeRunsContainer = document.createElement('div');
                activeRunsContainer.className = 'active-runs-container';
                activeRunsContainer.innerHTML = `
                    <h3 class="active-runs-title">Your Active Adventures</h3>
                    <p class="active-runs-info">Continue your journey or start a new one!</p>
                    <div class="active-runs-list"></div>
                `;
                
                const runsList = activeRunsContainer.querySelector('.active-runs-list');
                
                // Add each active run to the list
                runs.forEach(run => {
                    // Find story title from ID
                    const matchedStory = allStories.find(story => run.storyId === getStoryId(story));
                    if (!matchedStory) return; // Skip if story not found
                    
                    const storyName = matchedStory.title;
                    const currentStage = run.progress.currentStageIndex + 1;
                    const totalStages = matchedStory.stages.length;
                    const progress = Math.round((run.progress.completedStages / totalStages) * 100);
                    
                    const runElement = document.createElement('div');
                    runElement.className = 'active-run-item';
                    runElement.dataset.storyId = run.storyId; // Add data attribute for easier removal
                    runElement.innerHTML = `
                        <div class="run-info">
                            <h4 class="run-story-title">${storyName}</h4>
                            <div class="run-progress">
                                <div class="run-stage">Stage ${currentStage}/${totalStages}</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${progress}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="run-actions">
                            <button class="run-action-button continue-run-button">Continue</button>
                            <button class="run-action-button finish-run-button">Finish</button>
                        </div>
                    `;
                    
                    // Add click handler to continue button
                    const continueButton = runElement.querySelector('.continue-run-button');
                    continueButton.addEventListener('click', () => {
                        console.log(`Continuing story run: ${run.storyId}`);
                        window.location.href = `story.html?story=${run.storyId}`;
                    });

                    // Add click handler to finish button
                    const finishButton = runElement.querySelector('.finish-run-button');
                    finishButton.addEventListener('click', () => {
                        finishStoryRun(run.storyId, storyName, runElement); // Pass necessary info
                    });

                    runsList.appendChild(runElement);
                });
                
                // Add the active runs container before the story grid
                const storySectionHeader = document.querySelector('.selector-panel .panel-header');
                if (storySectionHeader && storySectionHeader.parentNode) {
                    storySectionHeader.parentNode.insertBefore(activeRunsContainer, storySectionHeader.nextSibling);
                } else {
                    // Fallback: add to story container if header not found
                    const storyContainer = document.getElementById('story-stage-grid');
                    if (storyContainer && storyContainer.parentNode) {
                        storyContainer.parentNode.insertBefore(activeRunsContainer, storyContainer);
                    } else {
                        console.warn('Could not find suitable location to insert active runs container');
                    }
                }
            }
            
            // Helper function to get story ID (prefer explicit ID, fall back to normalized title)
            function getStoryId(story) {
                return story.id || normalizeStoryId(story.title);
            }
            
            // Helper function to normalize story IDs (matches story manager normalization)
            function normalizeStoryId(title) {
                if (!title) return '';
                return title.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
            }

            // Function to Finish a Story Run
            async function finishStoryRun(storyId, storyTitle, runElement) {
                if (!confirm(`Are you sure you want to finish the story "${storyTitle}"? This will delete your current progress permanently.`)) {
                    return; // User cancelled
                }

                const userId = getCurrentUserId();
                if (!userId) {
                    showTooltip('Authentication error. Please log in again.');
                    return;
                }

                try {
                    await firebaseDatabase.ref(`users/${userId}/storyProgress/${storyId}`).remove();
                    console.log(`Successfully finished and deleted run for ${storyId}.`);
                    showTooltip(`Progress for "${storyTitle}" cleared.`);

                    // Remove the run element from the UI
                    runElement.remove();

                    // Remove from local activeRuns array
                    const runIndex = activeRuns.findIndex(run => run.storyId === storyId);
                    if (runIndex > -1) {
                        activeRuns.splice(runIndex, 1);
                    }

                    // If no more active runs, remove the container (optional)
                    const runsListContainer = document.querySelector('.active-runs-list');
                    if (runsListContainer && runsListContainer.children.length === 0) {
                        const activeRunsContainer = document.querySelector('.active-runs-container');
                        if(activeRunsContainer) activeRunsContainer.remove();
                    }

                } catch (error) {
                    console.error(`Error finishing run for ${storyId}:`, error);
                    showTooltip('Failed to finish the story run. Please try again.');
                }
            }
            
            // Helper function to get current user ID
            function getCurrentUserId() {
                const user = firebaseAuth.currentUser;
                return user ? user.uid : null;
            }

            // Quest Panel Functions
            function setupQuestPanel() {
                // Quest toggle functionality
                questToggle.addEventListener('click', () => {
                    const isOpen = questPanel.classList.contains('open');
                    if (isOpen) {
                        questPanel.classList.remove('open');
                        questToggle.classList.remove('panel-open');
                        questToggle.innerHTML = '📜';
                        questToggle.title = 'Open Quest Journal';
                    } else {
                        questPanel.classList.add('open');
                        questToggle.classList.add('panel-open');
                        questToggle.innerHTML = '✕';
                        questToggle.title = 'Close Quest Journal';
                        loadAndDisplayQuests(); // Load quests when panel opens
                    }
                });

                // Close panel when clicking outside (optional)
                document.addEventListener('click', (e) => {
                    if (!questPanel.contains(e.target) && !questToggle.contains(e.target)) {
                        if (questPanel.classList.contains('open')) {
                            questToggle.click(); // Trigger close
                        }
                    }
                });
            }

            async function loadAndDisplayQuests() {
                if (!window.questManager || !window.questManager.initialized) {
                    questList.innerHTML = '<div style="text-align: center; color: var(--neutral-400); padding: 20px;">Quest system not available</div>';
                    return;
                }

                try {
                    const quests = await window.questManager.getDisplayableQuests();
                    
                    if (!quests || quests.length === 0) {
                        questList.innerHTML = `
                            <div style="text-align: center; color: var(--neutral-400); padding: 20px;">
                                <div style="font-size: 1.2rem; margin-bottom: 10px;">📋</div>
                                <div>No quests available</div>
                                <div style="font-size: 0.8rem; margin-top: 5px; opacity: 0.7;">All quests completed or none available</div>
                            </div>
                        `;
                        return;
                    }

                    displayQuestList(quests);
                } catch (error) {
                    console.error('Error loading quests:', error);
                    questList.innerHTML = '<div style="text-align: center; color: var(--secondary); padding: 20px;">Error loading quests</div>';
                }
            }

            function displayQuestList(quests) {
                questList.innerHTML = '';

                if (quests.length === 0) {
                    questList.innerHTML = '<div style="text-align: center; color: var(--neutral-400); padding: 20px;">No quests available yet</div>';
                    return;
                }

                quests.forEach(quest => {
                    const questItem = createQuestItem(quest);
                    questList.appendChild(questItem);
                });
            }

            function createQuestItem(quest) {
                const questItem = document.createElement('div');
                questItem.className = 'quest-item';
                questItem.dataset.questId = quest.id;

                if (quest.isCompleted) {
                    questItem.classList.add('completed');
                }

                if (quest.canClaim) {
                    questItem.classList.add('can-claim');
                }

                questItem.innerHTML = `
                    <div class="quest-top">
                        <div class="quest-icon">${quest.icon}</div>
                        <div class="quest-info">
                            <div class="quest-name">${quest.name}</div>
                            <div class="quest-description">${quest.description}</div>
                        </div>
                    </div>
                    <div class="quest-progress">
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${quest.progressPercentage}%"></div>
                        </div>
                        <div class="quest-progress-text">
                            ${quest.isCompleted ? 'Completed!' : `${quest.progress} / ${quest.target}`}
                        </div>
                    </div>
                    <div class="quest-reward">
                        <div class="quest-reward-label">Reward</div>
                        <div class="quest-reward-text">${quest.reward.name}</div>
                    </div>
                    ${quest.canClaim ? `
                        <div class="quest-claim-section">
                            <button class="quest-claim-button" onclick="claimQuest('${quest.id}')">
                                🎁 Claim Reward
                            </button>
                        </div>
                    ` : ''}
                `;

                return questItem;
            }

            function showQuestCompletionNotification(quest) {
                // Remove any existing notification
                const existingNotification = document.querySelector('.quest-completion-notification');
                if (existingNotification) {
                    existingNotification.remove();
                }

                const notification = document.createElement('div');
                notification.className = 'quest-completion-notification';
                notification.innerHTML = `
                    <div class="quest-completion-content">
                        <div class="quest-completion-icon">🎉</div>
                        <div class="quest-completion-text">
                            <div class="quest-completion-title">Quest Complete!</div>
                            <div class="quest-completion-name">${quest.name}</div>
                            <div class="quest-completion-reward">Reward: ${quest.reward.name}</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Show notification
                setTimeout(() => {
                    notification.classList.add('show');
                }, 100);

                // Hide notification after 5 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 500);
                }, 5000);
            }

            // Quest claiming function
            window.claimQuest = async function(questId) {
                if (!window.questManager || !window.questManager.initialized) {
                    showTooltip('Quest system not available');
                    return;
                }

                try {
                    const result = await window.questManager.claimQuest(questId);
                    
                    if (result.success) {
                        showTooltip(result.message);
                        
                        // Refresh quest display
                        if (questPanel.classList.contains('open')) {
                            loadAndDisplayQuests();
                        }
                        
                        // Refresh character/stage grids in case new content was unlocked
                        if (result.reward.type === 'character') {
                            populateCharacterGrid(allCharacters);
                        } else if (result.reward.type === 'stage') {
                            populateStageGrid(allStages);
                        } else if (result.reward.type === 'story') {
                            populateStoryGrid(allStories);
                        }
                    } else {
                        showTooltip(`Failed to claim quest: ${result.error}`);
                    }
                } catch (error) {
                    console.error('Error claiming quest:', error);
                    showTooltip('Error claiming quest');
                }
            };

            // Listen for quest events
            if (typeof window !== 'undefined') {
                window.addEventListener('questCompleted', (event) => {
                    const quest = event.detail.quest;
                    showQuestCompletionNotification(quest);
                    
                    // Refresh quest display if panel is open
                    if (questPanel.classList.contains('open')) {
                        loadAndDisplayQuests();
                    }
                });

                window.addEventListener('questClaimed', (event) => {
                    const quest = event.detail.quest;
                    const reward = event.detail.reward;
                    
                    // Refresh quest display if panel is open
                    if (questPanel.classList.contains('open')) {
                        loadAndDisplayQuests();
                    }
                });
            }

            function createCharacterCard(character) {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.dataset.id = character.id;

                // Check if character is owned
                const isOwned = ownedCharacters.includes(character.id);
                if (!isOwned) {
                    card.classList.add('locked');
                }

                if (selectedCharacters.some(c => c.id === character.id)) {
                    card.classList.add('selected');
                }

                // Apply story/filter restrictions immediately
                applySingleCharacterRestrictions(card, character);
                
                const tagElements = character.tags && character.tags.length > 0 
                    ? character.tags.map(tag => `<span class="character-tag">${tag}</span>`).join('')
                    : '<span class="character-tag">No tags</span>';
                
                // Get the correct icon path
                const iconPath = getCharacterIconPath(character);
                
                card.innerHTML = `
                    <div class="character-image">
                        ${iconPath ? `<img src="${iconPath}" alt="${character.name}">` : `<div class="no-image">No Img</div>`}
                        ${!isOwned ? '<div class="lock-overlay">🔒</div>' : ''}
                        ${isOwned ? '<div class="character-level">Lv.1</div>' : ''}
                        ${isOwned ? '<div class="talent-points-indicator hidden" data-points="0">0</div>' : ''}
                    </div>
                    <div class="character-info">
                        <div class="character-name">${character.name}</div>
                        <div class="character-tags">${tagElements}</div>
                        ${isOwned ? '<div class="character-xp"><div class="xp-bar-small"><div class="xp-fill-small" style="width: 0%"></div></div><div class="xp-text-small">0 / 1000 XP</div></div>' : ''}
                         <button class="talents-button" data-char-id="${character.id}">Talents</button> 
                    </div>
                `;
                
                // Add click listener for character selection
                card.addEventListener('click', (e) => {
                    // Prevent selection if the talents button was clicked
                     if (e.target.classList.contains('talents-button')) {
                         return;
                     }
                    
                    if (card.classList.contains('locked')) {
                        showTooltip('You do not own this character.');
                        return;
                    }
                    if (!card.classList.contains('hidden') && !card.classList.contains('restricted')) {
                        selectCharacter(character);
                    }
                });
                
                // Add click listener for the Talents button
                const talentsButton = card.querySelector('.talents-button');
                if (talentsButton) {
                    talentsButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent card selection click
                        
                        // Redirect to talents page with character ID
                        window.location.href = `talents.html?character=${character.id}`;
                    });
                }
                
                return card;
            }

            function applySingleCharacterRestrictions(cardElement, character) {
                cardElement.classList.remove('hidden', 'restricted');
                let isRestricted = false;
                let isHiddenByTagFilter = false;
                const isOwned = ownedCharacters.includes(character.id);

                // Apply locked status first
                if (!isOwned) {
                    cardElement.classList.add('locked');
                } else {
                    cardElement.classList.remove('locked'); // Ensure not locked if owned
                }

                // 1. Apply Story Requirements (if a story is selected)
                if (currentSelectionMode === 'story' && selectedStory && selectedStory.requirements) {
                    const reqs = selectedStory.requirements;
                    // Check required tags
                    if (reqs.tags && reqs.tags.length > 0) {
                        const hasRequiredTag = reqs.tags.every(tag => character.tags && character.tags.includes(tag));
                        if (!hasRequiredTag) {
                            isRestricted = true;
                        }
                    }
                    // Add other requirement checks here if needed (e.g., specific character bans)
                } 
                // 2. Apply Stage Requirements (if a stage is selected)
                else if (currentSelectionMode === 'stage' && selectedStage) {
                    // For 5v5_blazing_school_day, recommend (but don't restrict to) School tag
                    if (selectedStage.id === '5v5_blazing_school_day' && (!character.tags || !character.tags.includes('School'))) {
                        // Just make slightly transparent but don't restrict
                        cardElement.style.opacity = '0.8';
                    }
                    
                    // Check for excluded characters in playerCharacterRestrictions
                    if (selectedStage.playerCharacterRestrictions && 
                        selectedStage.playerCharacterRestrictions.excluded &&
                        selectedStage.playerCharacterRestrictions.excluded.includes(character.id)) {
                        isRestricted = true;
                        cardElement.title = "This character cannot be used in this stage";
                    }
                }
                // 3. Apply Weekly Challenge Requirements (if a weekly challenge is selected)
                else if (currentSelectionMode === 'weekly' && selectedWeeklyChallenge) {
                    // Check for excluded characters (enemy team)
                    if (selectedWeeklyChallenge.enemies && selectedWeeklyChallenge.enemies.includes(character.id)) {
                        isRestricted = true;
                        cardElement.title = "This character is part of the enemy team and cannot be selected for this weekly challenge";
                    }
                }
                
                // 4. Apply Active Tag Filter
                if (activeTagFilter && (!character.tags || !character.tags.includes(activeTagFilter))) {
                    isHiddenByTagFilter = true;
                }

                // Apply visual restrictions
                if (cardElement.classList.contains('locked')) {
                    cardElement.style.cursor = 'not-allowed';
                    // Opacity is handled by the .locked CSS class
                } else if (isRestricted) {
                    // If restricted by story/stage/weekly but owned
                    cardElement.classList.add('restricted');
                    cardElement.style.opacity = '0.5';
                    cardElement.style.cursor = 'not-allowed';
                } else {
                    // Clear restriction styling if not restricted
                    cardElement.classList.remove('restricted');
                    cardElement.style.opacity = '';
                    cardElement.style.cursor = '';
                }
                
                if(isHiddenByTagFilter) {
                    cardElement.classList.add('hidden');
                } else {
                    cardElement.classList.remove('hidden');
                }
            }
            
            function applyStoryRestrictions() {
                // Don't run restrictions if user data is still loading
                if (isLoadingUserData) {
                    console.log("Skipping restrictions check, waiting for user data...");
                    return;
                }
                document.querySelectorAll('.character-card').forEach(card => {
                    const characterId = card.dataset.id;
                    const character = allCharacters.find(c => c.id === characterId);
                    if (character) {
                        applySingleCharacterRestrictions(card, character);
                    }
                });
                clearTeamIfNeeded();
                updateTeamRestrictionText();
                updateTeamSlotsUI();
            }

            function updateTeamSizeUI(newMaxSize, newMinSize) {
                maxTeamSize = newMaxSize;
                minTeamSize = newMinSize;
                teamSlotsContainer.innerHTML = '';
                for (let i = 0; i < maxTeamSize; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'team-slot';
                    slot.dataset.slot = i;
                    slot.textContent = 'Empty';
                    teamSlotsContainer.appendChild(slot);
                }
                updateTeamSlotsUI();
                selectedTeamTitle.textContent = `Your Team (${selectedCharacters.length}/${maxTeamSize})`;
            }
            
            function populateStoryGrid(stories) {
                storyContainer.innerHTML = '';
                
                // Sort stories so unlocked ones appear first
                const sortedStories = [...stories].sort((a, b) => {
                                    const aIsOwned = ownedStories.includes(getStoryId(a));
                const bIsOwned = ownedStories.includes(getStoryId(b));
                    
                    // If ownership status is different, prioritize owned stories
                    if (aIsOwned !== bIsOwned) {
                        return bIsOwned - aIsOwned; // Owned stories (true) come first
                    }
                    
                    // If ownership status is same, maintain original order
                    return 0;
                });
                
                sortedStories.forEach(story => {
                    if (story.stages && story.stages.length > 0) {
                        const storyWrapper = document.createElement('div');
                        storyWrapper.className = 'story-container';
                        storyWrapper.dataset.storyTitle = story.title;

                        // Check if story is owned
                        const isOwned = ownedStories.includes(getStoryId(story));
                        if (!isOwned) {
                            storyWrapper.classList.add('locked');
                        }

                        const storyTitleEl = document.createElement('h3');
                        storyTitleEl.className = 'story-title';
                        storyTitleEl.textContent = story.title;
                        if (!isOwned) {
                            storyTitleEl.innerHTML = `🔒 ${story.title}`;
                        }
                        storyWrapper.appendChild(storyTitleEl);

                        if (story.description) {
                            const storyDesc = document.createElement('div');
                            storyDesc.className = 'story-description';
                            storyDesc.textContent = story.description;
                            storyWrapper.appendChild(storyDesc);
                        }

                        storyWrapper.addEventListener('click', () => {
                            if (!isOwned) {
                                showTooltip('You do not own this story.');
                                return;
                            }
                            selectStory(story.title);
                        });

                        storyContainer.appendChild(storyWrapper);
                    }
                });

                if (storyContainer.children.length === 0) {
                    storyContainer.innerHTML = '<div class="empty-message">No stories available yet</div>';
                }
            }
            
            function populateTagFilters(tags) {
                tagFiltersContainer.innerHTML = '';
                
                // Add "All" filter
                const allFilterBtn = document.createElement('button');
                allFilterBtn.className = 'tag-filter-button active';
                allFilterBtn.textContent = 'All';
                allFilterBtn.dataset.tag = '';
                allFilterBtn.addEventListener('click', () => filterCharactersByTag(''));
                tagFiltersContainer.appendChild(allFilterBtn);
                
                // Add a button for each tag
                tags.sort().forEach(tag => {
                    const button = document.createElement('button');
                    button.className = 'tag-filter-button';
                    button.textContent = tag;
                    button.dataset.tag = tag;
                    button.addEventListener('click', () => filterCharactersByTag(tag));
                    tagFiltersContainer.appendChild(button);
                });
            }
            
            function filterCharactersByTag(tag) {
                activeTagFilter = tag === '' ? null : tag;
                
                document.querySelectorAll('.tag-filter-button').forEach(btn => {
                    const isActive = (btn.dataset.tag === tag) || (btn.dataset.tag === '' && !tag);
                    btn.classList.toggle('active', isActive);
                });
                
                applyStoryRestrictions();
            }
            
            function selectCharacter(character) {
                const existingIndex = selectedCharacters.findIndex(c => c.id === character.id);
                
                if (existingIndex !== -1) {
                    removeCharacter(existingIndex);
                    return;
                }

                if (selectedCharacters.length >= maxTeamSize) {
                    showTooltip(`Team full! Max size for this story is ${maxTeamSize}.`);
                    return;
                }
                
                // Check stage restrictions for excluded characters
                if (currentSelectionMode === 'stage' && selectedStage && 
                    selectedStage.playerCharacterRestrictions && 
                    selectedStage.playerCharacterRestrictions.excluded && 
                    selectedStage.playerCharacterRestrictions.excluded.includes(character.id)) {
                    showTooltip(`Character ${character.name} cannot be used in this stage.`);
                    return;
                }
                
                // Check story requirements
                if (selectedStory && selectedStory.requirements && selectedStory.requirements.tags) {
                    const hasRequiredTag = selectedStory.requirements.tags.every(tag => character.tags && character.tags.includes(tag));
                    if (!hasRequiredTag) {
                        showTooltip(`Character does not meet story tag requirements: ${selectedStory.requirements.tags.join(', ')}`);
                        return;
                    }
                }
                
                // Check weekly challenge enemy exclusions
                if (currentSelectionMode === 'weekly' && selectedWeeklyChallenge && selectedWeeklyChallenge.enemies && selectedWeeklyChallenge.enemies.includes(character.id)) {
                    showTooltip(`Character ${character.name} cannot be used in this weekly challenge.`);
                    return;
                }
                
                selectedCharacters.push(character);
                highlightSelectedCards();
                updateTeamSlotsUI();
                updateStartButtonState();
                // New: Notify QuestUIManager about the character change
                document.dispatchEvent(new CustomEvent('characterSelected', { detail: { character } }));
            }
            
            function selectStory(storyTitle) {
                const newlySelectedStory = allStories.find(s => s.title === storyTitle);
                if (!newlySelectedStory) return;

                // Check if story is owned
                const isOwned = ownedStories.includes(normalizeStoryId(storyTitle));
                if (!isOwned) {
                    showTooltip('You do not own this story.');
                    return;
                }

                const storyContainerElement = document.querySelector(`.story-container[data-story-title="${storyTitle}"]`);

                if (selectedStory && selectedStory.title === storyTitle) {
                    selectedStory = null;
                    if(storyContainerElement) storyContainerElement.classList.remove('selected');
                    updateTeamSizeUI(4, 1);
                    applyStoryRestrictions();
                    updateTeamRestrictionText();
                    clearTeamIfNeeded();
                    updateStartButtonState();
                    return;
                }

                const previouslySelected = document.querySelector('.story-container.selected');
                if (previouslySelected) {
                    previouslySelected.classList.remove('selected');
                }

                selectedStory = newlySelectedStory;
                if (storyContainerElement) storyContainerElement.classList.add('selected');

                const reqs = selectedStory.requirements || {};
                const newMaxSize = reqs.teamSize?.max ?? 4;
                const newMinSize = reqs.teamSize?.min ?? 1;

                updateTeamSizeUI(newMaxSize, newMinSize);
                applyStoryRestrictions();
                updateStartButtonState();
            }
            
            function populateStageGrid(stages) {
                stageContainer.innerHTML = '';
                
                // Sort stages so unlocked ones appear first
                const sortedStages = [...stages].sort((a, b) => {
                    const aIsOwned = ownedStages.includes(a.id);
                    const bIsOwned = ownedStages.includes(b.id);
                    
                    // If ownership status is different, prioritize owned stages
                    if (aIsOwned !== bIsOwned) {
                        return bIsOwned - aIsOwned; // Owned stages (true) come first
                    }
                    
                    // If ownership status is same, maintain original order
                    return 0;
                });
                
                sortedStages.forEach(stage => {
                    const card = document.createElement('div');
                    card.className = 'stage-card';
                    card.dataset.stageId = stage.id;
                    
                    // Check if stage is owned
                    const isOwned = ownedStages.includes(stage.id);
                    if (!isOwned) {
                        card.classList.add('locked');
                    }
                    
                    let difficultyClass = 'difficulty-easy';
                    if (stage.difficulty >= 7) {
                        difficultyClass = 'difficulty-hard';
                    } else if (stage.difficulty >= 4) {
                        difficultyClass = 'difficulty-medium';
                    }
                    
                    let backgroundStyle = '';
                    if (stage.backgroundImage) {
                        backgroundStyle = `background-image: url(${stage.backgroundImage});`;
                    }
                    
                    card.innerHTML = `
                        <div class="stage-image" style="${backgroundStyle}">
                            ${!backgroundStyle ? '<div class="no-image">No Image</div>' : ''}
                            <div class="difficulty-badge ${difficultyClass}">
                                <span>Difficulty: ${stage.difficulty}</span>
                            </div>
                            ${!isOwned ? '<div class="stage-lock-overlay">🔒</div>' : ''}
                        </div>
                        <div class="stage-info">
                            <div class="stage-name">${isOwned ? stage.name : '🔒 ' + stage.name}</div>
                            <div class="stage-desc">${stage.description || 'No description available'}</div>
                        </div>
                    `;
                    
                    card.addEventListener('click', () => {
                        if (!isOwned) {
                            showTooltip('You do not own this stage.');
                            return;
                        }
                        selectStage(stage.id);
                    });
                    stageContainer.appendChild(card);
                });
                
                if (stageContainer.children.length === 0) {
                    stageContainer.innerHTML = '<div class="empty-message">No stages available yet</div>';
                }
            }

            function populateWeeklyChallenges(challenges) {
                weeklyChallengesContainer.innerHTML = '';
                
                challenges.forEach(challenge => {
                    const card = createWeeklyChallengeCard(challenge);
                    weeklyChallengesContainer.appendChild(card);
                });
                
                if (weeklyChallengesContainer.children.length === 0) {
                    weeklyChallengesContainer.innerHTML = '<div class="empty-message">No weekly challenges available yet</div>';
                }
            }

            function createWeeklyChallengeCard(challenge) {
                const card = document.createElement('div');
                card.className = 'weekly-challenge-card';
                card.dataset.challengeId = challenge.id;
                
                if (!challenge.isAvailable) {
                    card.classList.add('locked');
                }
                
                // Create enemy list HTML
                const enemyListHTML = challenge.enemies.map(enemyId => 
                    `<span class="weekly-enemy-tag">${enemyId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</span>`
                ).join('');
                
                // Create modifiers HTML
                const modifiersHTML = challenge.modifiers.map(modifier => 
                    `<div class="weekly-modifier-item">${modifier.description}</div>`
                ).join('');
                
                // Create rewards HTML
                const rewardsHTML = challenge.rewards.map(reward => 
                    `<div class="weekly-reward-item">
                        <span class="weekly-reward-icon">${reward.icon}</span>
                        <span>${reward.name}</span>
                    </div>`
                ).join('');
                
                card.innerHTML = `
                    <div class="weekly-challenge-header">
                        <div class="weekly-challenge-icon">🏆</div>
                        <div>
                            <div class="weekly-challenge-title">${challenge.name}</div>
                            <div class="weekly-challenge-subtitle">
                                Weekly Challenge
                                <span class="weekly-timer">${challenge.timeRemaining}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="weekly-challenge-description">
                        ${challenge.description}
                    </div>
                    
                    <div class="weekly-modifiers">
                        <h4>Stage Modifiers</h4>
                        ${modifiersHTML}
                    </div>
                    
                    <div class="weekly-challenge-details">
                        <div class="weekly-detail-section enemies">
                            <h4>Enemies</h4>
                            <div class="weekly-enemy-list">
                                ${enemyListHTML}
                            </div>
                        </div>
                        <div class="weekly-detail-section rewards">
                            <h4>Rewards</h4>
                            ${rewardsHTML}
                        </div>
                    </div>
                    
                    <div class="weekly-challenge-status">
                        <div class="weekly-difficulty-badge">Difficulty ${challenge.difficulty}</div>
                        <div class="weekly-team-size">Team Size: ${challenge.teamSize} heroes</div>
                    </div>
                `;
                
                card.addEventListener('click', () => {
                    if (!challenge.isAvailable) {
                        showTooltip('This weekly challenge is not available.');
                        return;
                    }
                    selectWeeklyChallenge(challenge.id);
                });
                
                return card;
            }

            function selectWeeklyChallenge(challengeId) {
                const newlySelectedChallenge = allWeeklyChallenges.find(c => c.id === challengeId);
                if (!newlySelectedChallenge) return;
                
                if (!newlySelectedChallenge.isAvailable) {
                    showTooltip('This weekly challenge is not available.');
                    return;
                }
                
                const challengeCard = document.querySelector(`.weekly-challenge-card[data-challenge-id="${challengeId}"]`);
                
                if (selectedWeeklyChallenge && selectedWeeklyChallenge.id === challengeId) {
                    selectedWeeklyChallenge = null;
                    if (challengeCard) challengeCard.classList.remove('selected');
                    updateTeamSizeUI(4, 1); // Default
                    applyStoryRestrictions();
                    updateTeamRestrictionText();
                    clearTeamIfNeeded();
                    updateStartButtonState();
                    return;
                }
                
                const previouslySelected = document.querySelector('.weekly-challenge-card.selected');
                if (previouslySelected) {
                    previouslySelected.classList.remove('selected');
                }
                
                selectedWeeklyChallenge = newlySelectedChallenge;
                if (challengeCard) challengeCard.classList.add('selected');
                
                // Update team size for weekly challenge
                updateTeamSizeUI(selectedWeeklyChallenge.teamSize, 1);
                applyStoryRestrictions();
                updateTeamRestrictionText();
                updateStartButtonState();
            }
            
            function selectStage(stageId) {
                const newlySelectedStage = allStages.find(s => s.id === stageId);
                if (!newlySelectedStage) return;
                
                // Check if stage is owned
                const isOwned = ownedStages.includes(stageId);
                if (!isOwned) {
                    showTooltip('You do not own this stage.');
                    return;
                }
                
                const stageCard = document.querySelector(`.stage-card[data-stage-id="${stageId}"]`);
                
                if (selectedStage && selectedStage.id === stageId) {
                    selectedStage = null;
                    if (stageCard) stageCard.classList.remove('selected');
                    updateTeamSizeUI(4, 1); // Default
                    applyStoryRestrictions();
                    updateTeamRestrictionText();
                    clearTeamIfNeeded();
                    updateStartButtonState();
                    return;
                }
                
                const previouslySelected = document.querySelector('.stage-card.selected');
                if (previouslySelected) {
                    previouslySelected.classList.remove('selected');
                }
                
                selectedStage = newlySelectedStage;
                if (stageCard) stageCard.classList.add('selected');
                
                // Handle stage requirements
                if (selectedStage.requirements) {
                    const reqs = selectedStage.requirements;
                    const newMaxSize = reqs.teamSize?.max ?? 4;
                    const newMinSize = reqs.teamSize?.min ?? 1;
                    updateTeamSizeUI(newMaxSize, newMinSize);
                } else {
                    // Special cases for different stages (backwards compatibility)
                    if (stageId === '5v5_blazing_school_day') {
                        updateTeamSizeUI(5, 1);
                        // Optional: Tag filter for School characters
                        filterCharactersByTag('School');
                    } else if (stageId === 'farm_showdown') {
                        updateTeamSizeUI(5, 1); // 3v3 battle
                    } else {
                        updateTeamSizeUI(4, 1); // Default for other stages
                    }
                }
                
                applyStoryRestrictions();
                updateTeamRestrictionText();
                updateStartButtonState();
            }

            function updateTeamRestrictionText() {
                let text = "Select a story, stage, or weekly challenge to see requirements.";
                
                if (currentSelectionMode === 'story' && selectedStory) {
                    const reqs = selectedStory.requirements;
                    if (reqs) {
                        text = "Requirements: ";
                        let parts = [];
                        if (reqs.tags && reqs.tags.length > 0) {
                             parts.push(`Tags: [${reqs.tags.join(', ')}]`);
                        }
                        if (reqs.teamSize) {
                            if (reqs.teamSize.min && reqs.teamSize.max && reqs.teamSize.min === reqs.teamSize.max) {
                                parts.push(`Team Size: Exactly ${reqs.teamSize.max}`);
                            } else {
                                let sizeParts = [];
                                if(reqs.teamSize.min) sizeParts.push(`Min ${reqs.teamSize.min}`);
                                if(reqs.teamSize.max) sizeParts.push(`Max ${reqs.teamSize.max}`);
                                parts.push(`Team Size: ${sizeParts.join(', ')}`);
                            }
                        }
                         if (parts.length === 0) text += "None";
                         else text += parts.join(' | ');
                    } else {
                        text = "No specific requirements for this story. Max team size: " + maxTeamSize;
                    }
                } else if (currentSelectionMode === 'stage' && selectedStage) {
                    const reqs = selectedStage.requirements;
                    if (reqs) {
                        text = "Requirements: ";
                        let parts = [];
                        if (reqs.tags && reqs.tags.length > 0) {
                             parts.push(`Tags: [${reqs.tags.join(', ')}]`);
                        }
                        if (reqs.teamSize) {
                            if (reqs.teamSize.min && reqs.teamSize.max && reqs.teamSize.min === reqs.teamSize.max) {
                                parts.push(`Team Size: Exactly ${reqs.teamSize.max}`);
                            } else {
                                let sizeParts = [];
                                if(reqs.teamSize.min) sizeParts.push(`Min ${reqs.teamSize.min}`);
                                if(reqs.teamSize.max) sizeParts.push(`Max ${reqs.teamSize.max}`);
                                parts.push(`Team Size: ${sizeParts.join(', ')}`);
                            }
                        }
                         if (parts.length === 0) text += "None";
                         else text += parts.join(' | ');
                    } else {
                        // Special cases for backwards compatibility
                        if (selectedStage.id === '5v5_blazing_school_day') {
                            text = "Recommended: 5 School characters. Max team size: 5";
                        } else if (selectedStage.id === 'farm_showdown') {
                            text = "Beat the farmers! Farmers are not allowed on your team. Max team size: 3";
                        } else {
                            text = "No specific requirements for this stage. Max team size: " + maxTeamSize;
                        }
                    }
                } else if (currentSelectionMode === 'weekly' && selectedWeeklyChallenge) {
                    const bannedList = (selectedWeeklyChallenge.enemies || []).map(id => id.replace(/_/g,' ').replace(/\b\w/g, l => l.toUpperCase())).join(', ');
                    const modifiersText = selectedWeeklyChallenge.modifiers.map(m => m.description).join(', ');
                    text = `Weekly Challenge: ${selectedWeeklyChallenge.name}. Team Size: ${selectedWeeklyChallenge.teamSize}. Modifiers: ${modifiersText}. You cannot pick: ${bannedList}.`;
                }
                
                teamRestrictionText.textContent = text;
            }

            function clearTeamIfNeeded() {
                let teamChanged = false;
                const currentTeamSize = selectedCharacters.length;

                if (currentTeamSize > maxTeamSize) {
                    selectedCharacters.splice(maxTeamSize);
                    teamChanged = true;
                }

                let requiredTags = null;
                if (selectedStory && selectedStory.requirements && selectedStory.requirements.tags) {
                    requiredTags = selectedStory.requirements.tags;
                }

                if (requiredTags && requiredTags.length > 0) {
                    const originalLength = selectedCharacters.length;
                    selectedCharacters = selectedCharacters.filter(c => {
                         return requiredTags.every(tag => c.tags && c.tags.includes(tag));
                    });
                    if (selectedCharacters.length !== originalLength) {
                        teamChanged = true;
                    }
                }

                // Remove excluded characters if stage selected
                if (currentSelectionMode === 'stage' && selectedStage && 
                    selectedStage.playerCharacterRestrictions && 
                    selectedStage.playerCharacterRestrictions.excluded) {
                    const excludedCharacters = selectedStage.playerCharacterRestrictions.excluded;
                    const originalLength = selectedCharacters.length;
                    selectedCharacters = selectedCharacters.filter(c => !excludedCharacters.includes(c.id));
                    if (selectedCharacters.length !== originalLength) {
                        teamChanged = true;
                        console.log(`Removed ${originalLength - selectedCharacters.length} excluded characters from team`);
                    }
                }

                // Remove banned enemy characters if weekly challenge selected
                if (currentSelectionMode === 'weekly' && selectedWeeklyChallenge && selectedWeeklyChallenge.enemies) {
                    const banned = selectedWeeklyChallenge.enemies;
                    const originalLen = selectedCharacters.length;
                    selectedCharacters = selectedCharacters.filter(c => !banned.includes(c.id));
                    if (selectedCharacters.length !== originalLen) {
                        teamChanged = true;
                    }
                }

                if (teamChanged) {
                    selectedTeamTitle.textContent = `Your Team (${selectedCharacters.length}/${maxTeamSize})`;
                    updateTeamSlotsUI();
                    highlightSelectedCards();
                    updateStartButtonState();
                }
            }
            
            function updateTeamSlotsUI() {
                const slots = teamSlotsContainer.querySelectorAll('.team-slot');
                const isTeamSizeValid = selectedCharacters.length >= minTeamSize;

                slots.forEach((slot, index) => {
                    const character = selectedCharacters[index];
                    let newSlot = slot.cloneNode(true); // Clone upfront to modify before replacing
                    
                    // Determine slot state first
                    let isInvalid = !isTeamSizeValid && !character; // Invalid if team too small and slot is empty
                    let isFilled = !!character;
                    
                    // Apply classes to the clone
                    newSlot.className = 'team-slot'; // Start fresh
                    if (isFilled) newSlot.classList.add('filled');
                    if (isInvalid) newSlot.classList.add('invalid');

                    // Set content for the clone
                    if (character) {
                        const iconPath = getCharacterIconPath(character);
                        if (iconPath) {
                            newSlot.innerHTML = `<img src="${iconPath}" alt="${character.name}" title="${character.name}">`;
                        } else {
                            newSlot.textContent = character.name.substring(0, 10); // Fallback text
                            newSlot.innerHTML = ''; // Ensure no conflicting img tag if iconPath was temporarily truthy then null
                        }
                        newSlot.title = character.name;
                        
                        // Add remove listener only to filled slots
                        newSlot.addEventListener('click', (e) => {
                            // Check if the click target is the slot itself or the image inside
                            if (e.target === newSlot || e.target.tagName === 'IMG') {
                                removeCharacter(index);
                            }
                        });
                    } else {
                        newSlot.textContent = 'Empty';
                        newSlot.title = '';
                        newSlot.innerHTML = ''; // Clear any previous image/content
                        // No click listener needed for empty slots
                    }
                    
                    // Replace the original slot with the fully prepared new one
                    slot.replaceWith(newSlot);
                });
                
                // Update the team title with current count/max
                selectedTeamTitle.textContent = `Your Team (${selectedCharacters.length}/${maxTeamSize})`;
                updateStartButtonState(); // Check validity after UI update
            }

            function highlightSelectedCards() {
                document.querySelectorAll('.character-card').forEach(card => {
                    const cardId = card.dataset.id;
                    if (selectedCharacters.some(c => c.id === cardId)) {
                        card.classList.add('selected');
                    } else {
                        card.classList.remove('selected');
                    }
                });
            }
            
            function removeCharacter(index) {
                if (index < 0 || index >= selectedCharacters.length) return;
                const removedChar = selectedCharacters.splice(index, 1)[0];
                updateTeamSlotsUI();
                highlightSelectedCards();
                updateStartButtonState();
            }
             
            async function startBattle() {
                const userId = getCurrentUserId();
                if (!userId) {
                    showTooltip('Authentication error. Please log in again.');
                    return;
                }
                
                // Validate based on current selection mode
                if (currentSelectionMode === 'story') {
                    if (!selectedStory) {
                        showTooltip('Please select a story first!');
                        return;
                    }
                    
                    if (selectedCharacters.length < minTeamSize) {
                        showTooltip(`Team too small! Minimum size for this story is ${minTeamSize}.`);
                        return;
                    }
                    
                    let requiredTags = selectedStory.requirements?.tags;
                    if (requiredTags && requiredTags.length > 0) {
                        const teamIsValid = selectedCharacters.every(c =>
                            requiredTags.every(tag => c.tags && c.tags.includes(tag))
                        );
                        if (!teamIsValid) {
                            showTooltip(`One or more characters don't meet the required tags: [${requiredTags.join(', ')}]`);
                            return;
                        }
                    }
                    
                    const characterIdsToSend = selectedCharacters.map(c => c.id);
                    // Use the same normalization function as the story manager
                    const storyIdForUrl = getStoryId(selectedStory);
                    
                    // Check if there's an existing run for this story and delete it first
                    const existingRun = activeRuns.find(run => run.storyId === storyIdForUrl);
                    if (existingRun) {
                        // Ask for confirmation before deleting the existing run
                        if (!confirm(`You already have an active run of "${selectedStory.title}". Starting a new run will delete your current progress. Continue?`)) {
                            return; // User cancelled
                        }
                        
                        try {
                            await firebaseDatabase.ref(`users/${userId}/storyProgress/${storyIdForUrl}`).remove();
                            console.log(`Deleted existing run for ${storyIdForUrl} to start a new one.`);
                        } catch (error) {
                            console.error("Error deleting existing run:", error);
                            showTooltip('Failed to delete existing run. Please try again.');
                            return;
                        }
                    }

                    // Save selection to Firebase
                    try {
                        const updates = {};
                        updates[`users/${userId}/currentTeamSelection`] = characterIdsToSend;
                        updates[`users/${userId}/currentStorySelection`] = storyIdForUrl;
                        
                        await firebaseDatabase.ref().update(updates);
                        console.log('Saved current team and story selection to Firebase.');
                    } catch (error) {
                         console.error("Error saving selection to Firebase:", error);
                         showTooltip('Failed to save team selection. Please try again.');
                         return; // Prevent navigation if save fails
                    }

                    console.log('Starting story:', storyIdForUrl, 'with team IDs:', characterIdsToSend);
                    
                    // Navigate to story page (still using URL param for initial load)
                    window.location.href = `story.html?story=${storyIdForUrl}`;
                    
                } else if (currentSelectionMode === 'stage') {
                    if (!selectedStage) {
                        showTooltip('Please select a stage first!');
                        return;
                    }
                    
                    if (selectedCharacters.length < minTeamSize) {
                        showTooltip(`Team too small! Minimum size is ${minTeamSize}.`);
                        return;
                    }
                    
                    const characterIdsToSend = selectedCharacters.map(c => c.id);
                    
                    try {
                        // Save character selection to Firebase
                        await firebaseDatabase.ref(`users/${userId}/currentTeamSelection`).set(characterIdsToSend);
                        // Save selected stage
                        await firebaseDatabase.ref(`users/${userId}/currentStageSelection`).set({
                            id: selectedStage.id,
                            name: selectedStage.name
                        });
                        
                        console.log('Starting stage:', selectedStage.id, 'with team IDs:', characterIdsToSend);
                        
                        // Store stage data in localStorage for the battle to access
                        localStorage.setItem('selectedStage', JSON.stringify(selectedStage));
                        
                        // Navigate to battle page
                        window.location.href = `raid-game.html?stage=${selectedStage.id}`;
                        
                    } catch (error) {
                        console.error("Error saving selection to Firebase:", error);
                        showTooltip('Failed to save team selection. Please try again.');
                    }
                } else if (currentSelectionMode === 'weekly') {
                    if (!selectedWeeklyChallenge) {
                        showTooltip('Please select a weekly challenge first!');
                        return;
                    }
                    
                    if (selectedCharacters.length < minTeamSize) {
                        showTooltip(`Team too small! Minimum size is ${minTeamSize}.`);
                        return;
                    }
                    
                    const characterIdsToSend = selectedCharacters.map(c => c.id);
                    
                    try {
                        // Save character selection to Firebase
                        await firebaseDatabase.ref(`users/${userId}/currentTeamSelection`).set(characterIdsToSend);
                        // Save selected weekly challenge
                        await firebaseDatabase.ref(`users/${userId}/currentWeeklyChallengeSelection`).set({
                            id: selectedWeeklyChallenge.id,
                            name: selectedWeeklyChallenge.name
                        });
                        
                        console.log('Starting weekly challenge:', selectedWeeklyChallenge.id, 'with team IDs:', characterIdsToSend);
                        
                        // Build stage object dynamically from the selectedWeeklyChallenge definition
                        const weeklyStageData = {
                            id: selectedWeeklyChallenge.id,
                            name: selectedWeeklyChallenge.name,
                            description: selectedWeeklyChallenge.description,
                            difficulty: selectedWeeklyChallenge.difficulty,
                            type: 'weekly_challenge',
                            backgroundImage: "images/stages/burning_school_gym.jpg", // generic backdrop (override in JSON if needed)
                            backgroundMusic: "sounds/battle-epic.mp3",
                            enemies: (selectedWeeklyChallenge.enemies || []).map(enemyId => ({ characterId: enemyId })),
                            modifiers: selectedWeeklyChallenge.modifiers || [],
                            rewards: selectedWeeklyChallenge.rewards || [],
                            requirements: {
                                teamSize: {
                                    min: selectedWeeklyChallenge.teamSize || 1,
                                    max: selectedWeeklyChallenge.teamSize || 4
                                }
                            },
                            unlockRequirements: { type: 'always_unlocked' },
                            stageEffects: {},
                            isWeeklyChallenge: true
                        };
                        
                        // Store stage data in localStorage for the battle to access
                        localStorage.setItem('selectedStage', JSON.stringify(weeklyStageData));
                        
                        // Navigate to battle page
                        window.location.href = `raid-game.html?stage=${selectedWeeklyChallenge.id}&weekly=true`;
                        
                    } catch (error) {
                        console.error("Error saving weekly challenge selection to Firebase:", error);
                        showTooltip('Failed to save team selection. Please try again.');
                    }
                }
            }
             
            function showTooltip(message) {
                let tooltip = document.querySelector('.tooltip-message');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.className = 'tooltip-message';
                    document.body.appendChild(tooltip);
                }
                tooltip.textContent = message;
                
                tooltip.classList.remove('show');
                void tooltip.offsetWidth;

                tooltip.classList.add('show');
                setTimeout(() => {
                    tooltip.classList.remove('show');
                }, 2500);
            }

            function updateStartButtonState() {
                let enabled = true;
                let reason = "";
                if (!selectedStory && !selectedStage && !selectedWeeklyChallenge) {
                    enabled = false;
                    reason = "Select a story, stage, or weekly challenge";
                } else if (selectedCharacters.length < minTeamSize) {
                     enabled = false;
                     reason = `Need at least ${minTeamSize} character(s)`;
                } else if (selectedCharacters.length > maxTeamSize) {
                    enabled = false;
                    reason = `Team too large (max ${maxTeamSize})`;
                }
                
                startButton.disabled = !enabled;
                startButton.style.opacity = enabled ? '1' : '0.6';
                startButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
                
                let buttonText = "Start Battle";
                if (selectedWeeklyChallenge) {
                    buttonText = "Start Weekly Challenge";
                } else if (selectedStory) {
                    buttonText = "Start Story";
                } else if (selectedStage) {
                    buttonText = "Start Stage";
                }
                
                startButton.textContent = buttonText;
                startButton.title = enabled ? buttonText : reason;
            }

            startButton.addEventListener('click', startBattle);
            
            backButton.addEventListener('click', () => {
                window.location.href = 'index.html';
            });

            updateStartButtonState();

            // Quest Debug Functions
            window.debugAddQuestsToFirebase = async function() {
                console.log('[DEBUG] 🎯 Adding quests to Firebase database...');
                
                if (!firebaseDatabase || !firebaseAuth.currentUser) {
                    console.error('[DEBUG] ❌ Firebase not available or user not logged in');
                    return { success: false, error: 'Firebase not available or user not logged in' };
                }

                const questsData = {
                    "001": {
                        "name": "Turn Master",
                        "description": "Play 200 turns in battle",
                        "type": "battle",
                        "target": 200,
                        "progressKey": "turnsPlayed",
                        "reward": {
                            "type": "character",
                            "value": "bridget",
                            "name": "Bridget Character Unlock"
                        },
                        "icon": "⚔️",
                        "difficulty": "easy"
                    },
                    "002": {
                        "name": "Victory Streak",
                        "description": "Win 10 battles",
                        "type": "battle",
                        "target": 10,
                        "progressKey": "battlesWon",
                        "reward": {
                            "type": "character",
                            "value": "angel",
                            "name": "Angel Character Unlock"
                        },
                        "icon": "🏆",
                        "difficulty": "medium"
                    },
                    "003": {
                        "name": "First Steps",
                        "description": "Play 5 battles",
                        "type": "battle",
                        "target": 5,
                        "progressKey": "battlesPlayed",
                        "reward": {
                            "type": "stage",
                            "value": "elite_training_grounds",
                            "name": "Elite Training Grounds Unlock"
                        },
                        "icon": "🌟",
                        "difficulty": "easy"
                    },
                    "004": {
                        "name": "Story Seeker",
                        "description": "Complete 3 different stories",
                        "type": "story",
                        "target": 3,
                        "progressKey": "storiesCompleted",
                        "reward": {
                            "type": "story",
                            "value": "hidden_chronicles",
                            "name": "Hidden Chronicles Story Unlock"
                        },
                        "icon": "📖",
                        "difficulty": "hard"
                    },
                    "005": {
                        "name": "Damage Dealer",
                        "description": "Deal 10,000 total damage",
                        "type": "battle",
                        "target": 10000,
                        "progressKey": "totalDamageDealt",
                        "reward": {
                            "type": "character",
                            "value": "morrigan",
                            "name": "Morrigan Character Unlock"
                        },
                        "icon": "💥",
                        "difficulty": "medium"
                    }
                };

                try {
                    await firebaseDatabase.ref('quests').set(questsData);
                    console.log('[DEBUG] ✅ Successfully added quests to Firebase!');
                    console.log('[DEBUG] 📊 Added quests:', Object.keys(questsData));
                    
                    // Refresh quest manager to load new quests
                    if (window.questManager && window.questManager.initialized) {
                        await window.questManager.loadQuestRegistry();
                        console.log('[DEBUG] 🔄 Quest manager reloaded with new data');
                    }
                    
                    return { 
                        success: true, 
                        questCount: Object.keys(questsData).length,
                        quests: Object.keys(questsData)
                    };
                } catch (error) {
                    console.error('[DEBUG] ❌ Error adding quests to Firebase:', error);
                    return { success: false, error: error.message };
                }
            };

            window.debugAddSingleQuest = async function(questId, questData) {
                console.log(`[DEBUG] 🎯 Adding single quest ${questId} to Firebase...`);
                
                if (!firebaseDatabase || !firebaseAuth.currentUser) {
                    console.error('[DEBUG] ❌ Firebase not available or user not logged in');
                    return { success: false, error: 'Firebase not available or user not logged in' };
                }

                try {
                    await firebaseDatabase.ref(`quests/${questId}`).set(questData);
                    console.log(`[DEBUG] ✅ Successfully added quest ${questId}!`);
                    
                    // Refresh quest manager
                    if (window.questManager && window.questManager.initialized) {
                        await window.questManager.loadQuestRegistry();
                        console.log('[DEBUG] 🔄 Quest manager reloaded');
                    }
                    
                    return { success: true, questId, questData };
                } catch (error) {
                    console.error(`[DEBUG] ❌ Error adding quest ${questId}:`, error);
                    return { success: false, error: error.message };
                }
            };

            window.debugClearAllQuests = async function() {
                if (!confirm('⚠️ This will delete ALL quests from Firebase. Are you sure?')) {
                    return { success: false, cancelled: true };
                }
                
                console.log('[DEBUG] 🗑️ Clearing all quests from Firebase...');
                
                try {
                    await firebaseDatabase.ref('quests').remove();
                    console.log('[DEBUG] ✅ All quests cleared from Firebase');
                    
                    // Refresh quest manager
                    if (window.questManager && window.questManager.initialized) {
                        await window.questManager.loadQuestRegistry();
                        console.log('[DEBUG] 🔄 Quest manager reloaded (empty)');
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('[DEBUG] ❌ Error clearing quests:', error);
                    return { success: false, error: error.message };
                }
            };

            window.debugViewQuestsInDatabase = async function() {
                console.log('[DEBUG] 👀 Checking quests in Firebase database...');
                
                try {
                    const snapshot = await firebaseDatabase.ref('quests').once('value');
                    if (snapshot.exists()) {
                        const quests = snapshot.val();
                        console.log('[DEBUG] 📊 Found quests in database:', quests);
                        console.log(`[DEBUG] 📈 Total quest count: ${Object.keys(quests).length}`);
                        return { success: true, quests, count: Object.keys(quests).length };
                    } else {
                        console.log('[DEBUG] 📋 No quests found in database');
                        return { success: true, quests: null, count: 0 };
                    }
                } catch (error) {
                    console.error('[DEBUG] ❌ Error reading quests:', error);
                    return { success: false, error: error.message };
                }
            };

            // Individual Quest Creation Functions
            window.debugAdd001TurnMaster = async function() {
                return await debugAddSingleQuest("001", {
                    "name": "Turn Master",
                    "description": "Play 200 turns in battle",
                    "type": "battle",
                    "target": 200,
                    "progressKey": "turnsPlayed",
                    "reward": {
                        "type": "character",
                        "value": "bridget",
                        "name": "Bridget Character Unlock"
                    },
                    "icon": "⚔️",
                    "difficulty": "easy"
                });
            };

            window.debugAdd002VictoryStreak = async function() {
                return await debugAddSingleQuest("002", {
                    "name": "Victory Streak",
                    "description": "Win 10 battles",
                    "type": "battle",
                    "target": 10,
                    "progressKey": "battlesWon",
                    "reward": {
                        "type": "character",
                        "value": "angel",
                        "name": "Angel Character Unlock"
                    },
                    "icon": "🏆",
                    "difficulty": "medium"
                });
            };

            window.debugAdd003FirstSteps = async function() {
                return await debugAddSingleQuest("003", {
                    "name": "First Steps",
                    "description": "Play 5 battles",
                    "type": "battle",
                    "target": 5,
                    "progressKey": "battlesPlayed",
                    "reward": {
                        "type": "stage",
                        "value": "elite_training_grounds",
                        "name": "Elite Training Grounds Unlock"
                    },
                    "icon": "🌟",
                    "difficulty": "easy"
                });
            };

            window.debugAdd004StorySeeker = async function() {
                return await debugAddSingleQuest("004", {
                    "name": "Story Seeker",
                    "description": "Complete 3 different stories",
                    "type": "story",
                    "target": 3,
                    "progressKey": "storiesCompleted",
                    "reward": {
                        "type": "story",
                        "value": "hidden_chronicles",
                        "name": "Hidden Chronicles Story Unlock"
                    },
                    "icon": "📖",
                    "difficulty": "hard"
                });
            };

            window.debugAdd005DamageDealer = async function() {
                return await debugAddSingleQuest("005", {
                    "name": "Damage Dealer",
                    "description": "Deal 10,000 total damage",
                    "type": "battle",
                    "target": 10000,
                    "progressKey": "totalDamageDealt",
                    "reward": {
                        "type": "character",
                        "value": "morrigan",
                        "name": "Morrigan Character Unlock"
                    },
                    "icon": "💥",
                    "difficulty": "medium"
                });
            };

            window.debugRemoveQuest = async function(questId) {
                console.log(`[DEBUG] 🗑️ Removing quest ${questId} from Firebase...`);
                
                if (!firebaseDatabase || !firebaseAuth.currentUser) {
                    console.error('[DEBUG] ❌ Firebase not available or user not logged in');
                    return { success: false, error: 'Firebase not available or user not logged in' };
                }

                try {
                    await firebaseDatabase.ref(`quests/${questId}`).remove();
                    console.log(`[DEBUG] ✅ Successfully removed quest ${questId}!`);
                    
                    // Refresh quest manager
                    if (window.questManager && window.questManager.initialized) {
                        await window.questManager.loadQuestRegistry();
                        console.log('[DEBUG] 🔄 Quest manager reloaded');
                    }
                    
                    return { success: true, questId };
                } catch (error) {
                    console.error(`[DEBUG] ❌ Error removing quest ${questId}:`, error);
                    return { success: false, error: error.message };
                }
            };

            // Debug Functions - Available in browser console
            window.debugUnlockAllCharacters = function() {
                console.log('[DEBUG] Unlocking all characters temporarily...');
                
                // Store original owned characters for restoration if needed
                window._originalOwnedCharacters = [...ownedCharacters];
                
                // Unlock all characters by adding all character IDs to ownedCharacters
                ownedCharacters = allCharacters.map(char => char.id);
                
                // Re-populate the character grid to show unlocked characters
                populateCharacterGrid(allCharacters);
                
                console.log(`[DEBUG] Unlocked ${allCharacters.length} characters:`, ownedCharacters);
                console.log('[DEBUG] Characters will be locked again on page refresh.');
                console.log('[DEBUG] To restore original owned characters without refresh, call: debugRestoreOwnedCharacters()');
                
                return {
                    unlockedCount: allCharacters.length,
                    characters: allCharacters.map(c => c.name)
                };
            };

            window.debugRestoreOwnedCharacters = function() {
                if (window._originalOwnedCharacters) {
                    console.log('[DEBUG] Restoring original owned characters...');
                    ownedCharacters = [...window._originalOwnedCharacters];
                    populateCharacterGrid(allCharacters);
                    console.log('[DEBUG] Restored owned characters:', ownedCharacters);
                    return { restored: true, ownedCount: ownedCharacters.length };
                } else {
                    console.log('[DEBUG] No original owned characters stored. Use debugUnlockAllCharacters() first.');
                    return { restored: false, message: 'No backup found' };
                }
            };

            window.debugUnlockAllStages = function() {
                console.log('[DEBUG] Unlocking all stages temporarily...');
                
                // Store original owned stages for restoration if needed
                window._originalOwnedStages = [...ownedStages];
                
                // Unlock all stages by adding all stage IDs to ownedStages
                ownedStages = allStages.map(stage => stage.id);
                
                // Re-populate the stage grid to show unlocked stages
                populateStageGrid(allStages);
                
                console.log(`[DEBUG] Unlocked ${allStages.length} stages:`, ownedStages);
                console.log('[DEBUG] Stages will be locked again on page refresh.');
                
                return {
                    unlockedCount: allStages.length,
                    stages: allStages.map(s => s.name)
                };
            };

            window.debugUnlockAllStories = function() {
                console.log('[DEBUG] Unlocking all stories temporarily...');
                
                // Store original owned stories for restoration if needed
                window._originalOwnedStories = [...ownedStories];
                
                // Unlock all stories by adding all story IDs to ownedStories
                ownedStories = allStories.map(story => getStoryId(story));
                
                // Re-populate the story grid to show unlocked stories
                populateStoryGrid(allStories);
                
                console.log(`[DEBUG] Unlocked ${allStories.length} stories:`, ownedStories);
                console.log('[DEBUG] Stories will be locked again on page refresh.');
                
                return {
                    unlockedCount: allStories.length,
                    stories: allStories.map(s => s.title)
                };
            };

            // Admin functions for remote story control
            window.adminEnableStory = async function(storyId) {
                if (!firebaseDatabase) {
                    console.error('[Admin] Firebase not initialized');
                    return false;
                }
                
                try {
                    console.log(`[Admin] Enabling story globally: ${storyId}`);
                    await firebaseDatabase.ref(`globalSettings/storyAvailability/${storyId}`).set(true);
                    console.log(`[Admin] ✅ Story ${storyId} enabled globally`);
                    
                    // Refresh the page to apply changes
                    if (confirm('Story enabled globally! Refresh the page to see changes?')) {
                        window.location.reload();
                    }
                    
                    return true;
                } catch (error) {
                    console.error(`[Admin] Error enabling story ${storyId}:`, error);
                    return false;
                }
            };

            window.adminDisableStory = async function(storyId) {
                if (!firebaseDatabase) {
                    console.error('[Admin] Firebase not initialized');
                    return false;
                }
                
                try {
                    console.log(`[Admin] Disabling story globally: ${storyId}`);
                    await firebaseDatabase.ref(`globalSettings/storyAvailability/${storyId}`).set(false);
                    console.log(`[Admin] ✅ Story ${storyId} disabled globally`);
                    
                    // Refresh the page to apply changes
                    if (confirm('Story disabled globally! Refresh the page to see changes?')) {
                        window.location.reload();
                    }
                    
                    return true;
                } catch (error) {
                    console.error(`[Admin] Error disabling story ${storyId}:`, error);
                    return false;
                }
            };

            window.adminResetStoryToDefault = async function(storyId) {
                if (!firebaseDatabase) {
                    console.error('[Admin] Firebase not initialized');
                    return false;
                }
                
                try {
                    console.log(`[Admin] Resetting story to default availability: ${storyId}`);
                    await firebaseDatabase.ref(`globalSettings/storyAvailability/${storyId}`).remove();
                    console.log(`[Admin] ✅ Story ${storyId} reset to default availability (uses local playerunlocked setting)`);
                    
                    // Refresh the page to apply changes
                    if (confirm('Story reset to default! Refresh the page to see changes?')) {
                        window.location.reload();
                    }
                    
                    return true;
                } catch (error) {
                    console.error(`[Admin] Error resetting story ${storyId}:`, error);
                    return false;
                }
            };

            window.adminCheckStoryAvailability = async function() {
                if (!firebaseDatabase) {
                    console.error('[Admin] Firebase not initialized');
                    return null;
                }
                
                try {
                    const snapshot = await firebaseDatabase.ref('globalSettings/storyAvailability').once('value');
                    const settings = snapshot.exists() ? snapshot.val() : {};
                    
                    console.log('[Admin] Current global story availability settings:');
                    console.table(settings);
                    
                    return settings;
                } catch (error) {
                    console.error('[Admin] Error checking story availability:', error);
                    return null;
                }
            };

            // Helper function to quickly enable/disable corruption story
            window.adminToggleCorruptionStory = async function() {
                const currentSettings = await window.adminCheckStoryAvailability();
                if (!currentSettings) return false;
                
                const currentState = currentSettings.corruption_at_the_farmland;
                console.log(`[Admin] Current state of corruption_at_the_farmland: ${currentState}`);
                
                if (currentState === true) {
                    // Currently enabled, disable it
                    return await window.adminDisableStory('corruption_at_the_farmland');
                } else {
                    // Currently disabled or default, enable it
                    return await window.adminEnableStory('corruption_at_the_farmland');
                }
            };

            console.log('[Admin] Story control functions available:');
            console.log('- adminEnableStory(storyId) - Enable story globally');
            console.log('- adminDisableStory(storyId) - Disable story globally');  
            console.log('- adminResetStoryToDefault(storyId) - Reset to local setting');
            console.log('- adminCheckStoryAvailability() - Check current settings');
            console.log('- adminToggleCorruptionStory() - Quick toggle for corruption story');
            console.log('Example: adminToggleCorruptionStory() or adminEnableStory("corruption_at_the_farmland")');

            // Auto-run status check
            setTimeout(() => {
                window.adminCheckStoryAvailability();
            }, 2000);

            window.debugUnlockEverything = function() {
                console.log('[DEBUG] 🔓 UNLOCKING EVERYTHING! 🔓');
                
                const results = {
                    characters: debugUnlockAllCharacters(),
                    stages: debugUnlockAllStages(),
                    stories: debugUnlockAllStories()
                };
                
                console.log('[DEBUG] ✅ Everything unlocked! Results:', results);
                console.log('[DEBUG] 🔧 Available debug commands:');
                console.log('  - debugUnlockAllCharacters() - Unlock all characters');
                console.log('  - debugUnlockAllStages() - Unlock all stages');
                console.log('  - debugUnlockAllStories() - Unlock all stories');
                console.log('  - debugUnlockEverything() - Unlock everything');
                console.log('  - debugRestoreOwnedCharacters() - Restore original character ownership');
                console.log('[DEBUG] 🔄 Everything will be locked again on page refresh.');
                
                return results;
            };

            // Debug commands are now admin-only - console display handled by admin console

            // Debug Functions - Available in browser console
            
            // Add new debug function for quest troubleshooting
            window.debugCheckQuestProgress = async function(questId = "001") {
                console.log(`[DEBUG] 🔍 Checking quest progress for quest ${questId}...`);
                
                if (!window.questManager || !window.questManager.initialized) {
                    console.error('[DEBUG] ❌ Quest manager not initialized');
                    return { error: 'Quest manager not initialized' };
                }
                
                try {
                    // Check if quest exists in registry
                    const quest = window.questManager.questRegistry.find(q => q.id === questId);
                    if (!quest) {
                        console.error(`[DEBUG] ❌ Quest ${questId} not found in registry`);
                        return { error: `Quest ${questId} not found in registry` };
                    }
                    
                    console.log(`[DEBUG] ✅ Found quest: ${quest.name}`);
                    console.log(`[DEBUG] 📊 Progress Key: ${quest.progressKey}`);
                    console.log(`[DEBUG] 🎯 Target: ${quest.target}`);
                    
                    // Check current progress
                    const currentProgress = window.questManager.userQuestProgress[questId] || 0;
                    console.log(`[DEBUG] 📈 Current Progress: ${currentProgress}/${quest.target}`);
                    
                    // Check if completed
                    const isCompleted = window.questManager.completedQuests.has(questId);
                    console.log(`[DEBUG] ✔️ Is Completed: ${isCompleted}`);
                    
                    // Check Firebase data directly
                    const userId = getCurrentUserId();
                    if (userId) {
                        const progressSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUEST/${questId}`).once('value');
                        const firebaseProgress = progressSnapshot.exists() ? progressSnapshot.val() : 0;
                        console.log(`[DEBUG] 🔥 Firebase Progress: ${firebaseProgress}`);
                        
                        const completedSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUESTDONE/${questId}`).once('value');
                        const firebaseCompleted = completedSnapshot.exists() ? completedSnapshot.val() : false;
                        console.log(`[DEBUG] 🔥 Firebase Completed: ${firebaseCompleted}`);
                    }
                    
                    return {
                        quest,
                        currentProgress,
                        isCompleted,
                        progressPercentage: Math.min((currentProgress / quest.target) * 100, 100)
                    };
                } catch (error) {
                    console.error('[DEBUG] ❌ Error checking quest progress:', error);
                    return { error: error.message };
                }
            };

            window.debugSimulateTurns = async function(numTurns = 5) {
                console.log(`[DEBUG] 🎲 Simulating ${numTurns} turns for quest testing...`);
                
                if (!window.questManager || !window.questManager.initialized) {
                    console.error('[DEBUG] ❌ Quest manager not initialized');
                    return { error: 'Quest manager not initialized' };
                }
                
                try {
                    for (let i = 0; i < numTurns; i++) {
                        await window.questManager.updateQuestProgress('turnsPlayed', 1);
                        console.log(`[DEBUG] ⚔️ Simulated turn ${i + 1}`);
                    }
                    
                    console.log(`[DEBUG] ✅ Simulated ${numTurns} turns successfully`);
                    
                    // Check progress after simulation
                    const result = await debugCheckQuestProgress("001");
                    return result;
                } catch (error) {
                    console.error('[DEBUG] ❌ Error simulating turns:', error);
                    return { error: error.message };
                }
            };

            window.debugClaimQuest = async function(questId = "001") {
                console.log(`[DEBUG] 🎁 Attempting to claim quest ${questId}...`);
                
                if (!window.questManager || !window.questManager.initialized) {
                    console.error('[DEBUG] ❌ Quest manager not initialized');
                    return { error: 'Quest manager not initialized' };
                }
                
                try {
                    const result = await window.questManager.claimQuest(questId);
                    
                    if (result.success) {
                        console.log(`[DEBUG] ✅ Successfully claimed quest ${questId}!`);
                        console.log(`[DEBUG] 🎁 Reward: ${result.reward.name}`);
                        return result;
                    } else {
                        console.error(`[DEBUG] ❌ Failed to claim quest: ${result.error}`);
                        return result;
                    }
                } catch (error) {
                    console.error('[DEBUG] ❌ Error claiming quest:', error);
                    return { error: error.message };
                }
            };

            window.debugCompleteQuest = async function(questId = "001") {
                console.log(`[DEBUG] 🚀 Force completing quest ${questId}...`);
                
                if (!window.questManager || !window.questManager.initialized) {
                    console.error('[DEBUG] ❌ Quest manager not initialized');
                    return { error: 'Quest manager not initialized' };
                }
                
                try {
                    const quest = window.questManager.questRegistry.find(q => q.id === questId);
                    if (!quest) {
                        console.error(`[DEBUG] ❌ Quest ${questId} not found`);
                        return { error: 'Quest not found' };
                    }
                    
                    // Force complete by setting progress to target
                    await window.questManager.updateQuestProgress(quest.progressKey, quest.target);
                    console.log(`[DEBUG] ✅ Force completed quest ${questId} (${quest.name})`);
                    
                    return { success: true, quest };
                } catch (error) {
                    console.error('[DEBUG] ❌ Error force completing quest:', error);
                    return { error: error.message };
                }
            };

            window.debugUnlockAllCharacters = function() {
                console.log('[DEBUG] Unlocking all characters temporarily...');
                
                // Store original owned characters for restoration if needed
                window._originalOwnedCharacters = [...ownedCharacters];
                
                // Unlock all characters by adding all character IDs to ownedCharacters
                ownedCharacters = allCharacters.map(char => char.id);
                
                // Re-populate the character grid to show unlocked characters
                populateCharacterGrid(allCharacters);
                
                console.log(`[DEBUG] Unlocked ${allCharacters.length} characters:`, ownedCharacters);
                console.log('[DEBUG] Characters will be locked again on page refresh.');
                console.log('[DEBUG] To restore original owned characters without refresh, call: debugRestoreOwnedCharacters()');
                
                return {
                    unlockedCount: allCharacters.length,
                    characters: allCharacters.map(c => c.name)
                };
            };

            // Add Healing Quest to Firebase
            window.debugAddHealingQuest = async function() {
                console.log('[DEBUG] 🎯 Adding Healing Quest to Firebase...');
                
                const healingQuestData = {
                    "name": "Master Healer",
                    "description": "Heal a total of 100,000 HP across all battles",
                    "type": "healing",
                    "target": 100000,
                    "progressKey": "totalHealingDone",
                    "reward": {
                        "type": "student_character_choice",
                        "name": "Choice of Student Character",
                        "description": "Choose any Student character to unlock"
                    },
                    "icon": "💚",
                    "difficulty": "medium"
                };

                return await debugAddSingleQuest("heal_100k", healingQuestData);
            };

            // Alias for healing quest (consistent with numbered quest pattern)
            window.debugAdd006HealingQuest = window.debugAddHealingQuest;

            // Quest Character Choice System
            class QuestCharacterChoiceSystem {
                constructor() {
                    this.modal = null;
                    this.onCharacterSelected = null;
                }

                async showStudentCharacterChoice(questId, questName) {
                    console.log('[QuestReward] 🎓 Showing Student character choice for quest:', questName);
                    
                    try {
                        // Check if this quest reward is already pending (unclaimed)
                        const hasPendingReward = await this.checkPendingCharacterReward(questId);
                        if (hasPendingReward) {
                            console.log('[QuestReward] ⏳ Found existing unclaimed reward for quest:', questId);
                            // Show the choice modal directly without checking quest status again
                        }
                        
                        // Get all School tagged characters
                        const schoolCharacters = await this.getSchoolCharacters();
                        
                        // Check which ones are already owned
                        const ownedCharacters = await this.getOwnedCharacters();
                        const availableCharacters = schoolCharacters.filter(char => {
                            const charId = char.id;
                            const charName = char.name;
                            
                            // Check if character is marked as free/default in character data
                            const isFreeCharacter = char.isFree || char.free || char.default || char.starter;
                            if (isFreeCharacter) {
                                console.log(`[QuestReward] 🆓 ${charName} is marked as free/default character - EXCLUDING`);
                                return false;
                            }
                            
                            // Create all possible variants of this character ID/name
                            const variants = new Set([
                                charId,
                                charName,
                                charId.toLowerCase(),
                                charName.toLowerCase(),
                                charId.replace(/\s+/g, '_'),
                                charName.replace(/\s+/g, '_'),
                                charId.replace(/\s+/g, '_').toLowerCase(),
                                charName.replace(/\s+/g, '_').toLowerCase(),
                                // Add capitalized versions
                                charId.split(/[\s_]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('_'),
                                charName.split(/[\s_]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('_'),
                                // Add space versions
                                charId.replace(/_/g, ' '),
                                charName.replace(/_/g, ' '),
                                charId.replace(/_/g, ' ').toLowerCase(),
                                charName.replace(/_/g, ' ').toLowerCase()
                            ]);
                            
                            // Check if any variant matches any owned character
                            const isOwned = ownedCharacters.some(owned => {
                                return variants.has(owned) || 
                                       variants.has(owned.toLowerCase()) ||
                                       variants.has(owned.replace(/\s+/g, '_')) ||
                                       variants.has(owned.replace(/\s+/g, '_').toLowerCase()) ||
                                       variants.has(owned.replace(/_/g, ' ')) ||
                                       variants.has(owned.replace(/_/g, ' ').toLowerCase());
                            });
                            
                            console.log(`[QuestReward] 🔍 Checking ${charName} (${charId}): ${isOwned ? '❌ OWNED' : '✅ AVAILABLE'}`);
                            if (isOwned) {
                                const matchingOwned = ownedCharacters.filter(owned => 
                                    variants.has(owned) || 
                                    variants.has(owned.toLowerCase()) ||
                                    variants.has(owned.replace(/\s+/g, '_')) ||
                                    variants.has(owned.replace(/\s+/g, '_').toLowerCase()) ||
                                    variants.has(owned.replace(/_/g, ' ')) ||
                                    variants.has(owned.replace(/_/g, ' ').toLowerCase())
                                );
                                console.log(`[QuestReward] 📌 Matched owned: ${matchingOwned.join(', ')}`);
                            }
                            
                            return !isOwned;
                        });
                        
                        if (availableCharacters.length === 0) {
                            console.log('[QuestReward] ℹ️ All Student characters are already owned');
                            this.showInfoNotification('All Student characters are already owned! Here are some bonus talent points instead.');
                            
                            // Award talent points as alternative reward
                            await this.awardAlternativeReward(questId);
                            return;
                        }
                        
                        this.createCharacterChoiceModal(availableCharacters, questId, questName);
                        
                    } catch (error) {
                        console.error('[QuestReward] ❌ Error showing character choice:', error);
                        this.showErrorNotification('Error loading character choices. Please try again.');
                    }
                }

                async getSchoolCharacters() {
                    const response = await fetch('characters.json');
                    const charactersData = await response.json();
                    
                    // Handle array format - create proper character objects with names as IDs
                    const schoolCharacters = charactersData
                        .filter(char => char.tags && char.tags.includes('School'))
                        .map(char => ({
                            id: char.name.toLowerCase().replace(/\s+/g, '_'), // Convert name to ID format
                            ...char
                        }));
                    
                    console.log('[QuestReward] Found School characters:', schoolCharacters.map(c => c.id));
                    console.log('[QuestReward] School character details:', schoolCharacters.map(c => ({
                        id: c.id,
                        name: c.name,
                        tags: c.tags,
                        isFree: c.isFree || c.free || c.default || c.starter
                    })));
                    
                    return schoolCharacters;
                }

                async getOwnedCharacters() {
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        return [];
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        const allOwnedCharacters = new Set();
                        
                        console.log('[QuestReward] 🔍 Checking character ownership in both folders...');
                        
                        // Add default/free characters that everyone gets
                        const defaultCharacters = [
                            'schoolboy_shoma',
                            'Schoolboy Shoma',
                            'schoolboy shoma',
                            'Shoma',
                            'shoma'
                        ];
                        
                        defaultCharacters.forEach(charId => {
                            allOwnedCharacters.add(charId);
                        });
                        console.log('[QuestReward] 🆓 Added default/free characters to owned list');
                        
                        // Check ownedCharacters folder
                        const ownedSnapshot = await firebaseDatabase.ref(`users/${userId}/ownedCharacters`).once('value');
                        if (ownedSnapshot.exists()) {
                            const ownedData = ownedSnapshot.val();
                            console.log('[QuestReward] 📁 ownedCharacters folder data:', ownedData);
                            
                            if (Array.isArray(ownedData)) {
                                ownedData.forEach(charId => {
                                    allOwnedCharacters.add(charId);
                                    console.log(`[QuestReward] ✅ Found in ownedCharacters: ${charId}`);
                                });
                            } else if (typeof ownedData === 'object' && ownedData !== null) {
                                Object.keys(ownedData).forEach(charId => {
                                    if (ownedData[charId] === true || ownedData[charId] === 1) {
                                        allOwnedCharacters.add(charId);
                                        console.log(`[QuestReward] ✅ Found in ownedCharacters: ${charId}`);
                                    }
                                });
                            }
                        } else {
                            console.log('[QuestReward] 📁 ownedCharacters folder: empty or not found');
                        }
                        
                        // Check UnlockedRAIDCharacters folder
                        const raidSnapshot = await firebaseDatabase.ref(`users/${userId}/UnlockedRAIDCharacters`).once('value');
                        if (raidSnapshot.exists()) {
                            const raidData = raidSnapshot.val();
                            console.log('[QuestReward] 📁 UnlockedRAIDCharacters folder data:', raidData);
                            
                            if (Array.isArray(raidData)) {
                                raidData.forEach(charId => {
                                    allOwnedCharacters.add(charId);
                                    console.log(`[QuestReward] ✅ Found in UnlockedRAIDCharacters: ${charId}`);
                                });
                            } else if (typeof raidData === 'object' && raidData !== null) {
                                Object.keys(raidData).forEach(charId => {
                                    // UnlockedRAIDCharacters contains objects with source/timestamp info
                                    allOwnedCharacters.add(charId);
                                    console.log(`[QuestReward] ✅ Found in UnlockedRAIDCharacters: ${charId}`, raidData[charId]);
                                });
                            }
                        } else {
                            console.log('[QuestReward] 📁 UnlockedRAIDCharacters folder: empty or not found');
                        }
                        
                        const ownedArray = Array.from(allOwnedCharacters);
                        console.log('[QuestReward] 📋 All owned characters found (including defaults):', ownedArray);
                        return ownedArray;
                        
                    } catch (error) {
                        console.error('[QuestReward] ❌ Error getting owned characters:', error);
                        return [];
                    }
                }

                createCharacterChoiceModal(characters, questId, questName) {
                    // Remove existing modal if any
                    this.removeModal();

                    // Create modal
                    this.modal = document.createElement('div');
                    this.modal.className = 'quest-reward-modal-overlay';
                    this.modal.innerHTML = `
                        <div class="quest-reward-modal">
                            <div class="quest-reward-header">
                                <div class="quest-complete-icon">✨</div>
                                <h2>Quest Complete!</h2>
                                <h3>${questName}</h3>
                                <p>Choose your Student character reward:</p>
                            </div>
                            <div class="character-choice-grid">
                                ${characters.map((char, index) => {
                                    console.log(`[QuestReward] 🏗️ Generating HTML for character ${index}:`, { id: char.id, name: char.name });
                                    return `
                                    <div class="character-choice-card" data-character-id="${char.id}">
                                        <div class="character-image-container">
                                            <img src="${char.image}" alt="${char.name}" onerror="this.src='Icons/characters/default.png'">
                                            <div class="character-overlay">
                                                <span class="select-text">SELECT</span>
                                            </div>
                                        </div>
                                        <div class="character-info">
                                            <h4>${char.name}</h4>
                                            <div class="character-tags">
                                                ${char.tags.map(tag => `<span class="tag tag-${tag.toLowerCase()}">${tag}</span>`).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                                }).join('')}
                            </div>
                            <div class="quest-reward-actions">
                                <button class="cancel-button" onclick="window.questCharacterChoice.closeModal()">
                                    <span>✕</span> Close
                                </button>
                            </div>
                        </div>
                    `;

                    // Add styles
                    if (!document.querySelector('#quest-reward-styles')) {
                        const styles = document.createElement('style');
                        styles.id = 'quest-reward-styles';
                        styles.textContent = `
                            .quest-reward-modal-overlay {
                                position: fixed;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: rgba(0, 0, 0, 0.85);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                z-index: 10000;
                                backdrop-filter: blur(8px);
                                animation: overlayFadeIn 0.3s ease-out;
                            }

                            @keyframes overlayFadeIn {
                                from { opacity: 0; backdrop-filter: blur(0px); }
                                to { opacity: 1; backdrop-filter: blur(8px); }
                            }

                            .quest-reward-modal {
                                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                                border-radius: 20px;
                                padding: 40px;
                                max-width: 900px;
                                width: 95%;
                                max-height: 85vh;
                                overflow-y: auto;
                                border: 1px solid rgba(59, 130, 246, 0.3);
                                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.1);
                                position: relative;
                                animation: questModalAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                            }

                            .quest-reward-modal::before {
                                content: '';
                                position: absolute;
                                top: 0;
                                left: 0;
                                right: 0;
                                height: 1px;
                                background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.8), transparent);
                            }

                            @keyframes questModalAppear {
                                from { 
                                    opacity: 0; 
                                    transform: scale(0.8) translateY(-40px) rotateX(10deg);
                                    filter: blur(10px);
                                }
                                to { 
                                    opacity: 1; 
                                    transform: scale(1) translateY(0) rotateX(0deg);
                                    filter: blur(0px);
                                }
                            }

                            .quest-reward-header {
                                text-align: center;
                                margin-bottom: 35px;
                                position: relative;
                            }

                            .quest-complete-icon {
                                font-size: 4rem;
                                margin-bottom: 15px;
                                animation: sparkle 2s infinite;
                                display: block;
                            }

                            @keyframes sparkle {
                                0%, 100% { transform: scale(1) rotate(0deg); opacity: 1; }
                                50% { transform: scale(1.1) rotate(10deg); opacity: 0.8; }
                            }

                            .quest-reward-header h2 {
                                font-size: 2.5rem;
                                background: linear-gradient(135deg, #fbbf24, #f59e0b, #d97706);
                                background-clip: text;
                                -webkit-background-clip: text;
                                -webkit-text-fill-color: transparent;
                                margin-bottom: 10px;
                                font-weight: 700;
                                text-shadow: 0 2px 10px rgba(251, 191, 36, 0.3);
                            }

                            .quest-reward-header h3 {
                                color: #e2e8f0;
                                margin-bottom: 12px;
                                font-size: 1.2rem;
                                font-weight: 500;
                            }

                            .quest-reward-header p {
                                color: #94a3b8;
                                font-size: 1rem;
                            }

                            .character-choice-grid {
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                                gap: 20px;
                                margin-bottom: 35px;
                            }

                            .character-choice-card {
                                background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
                                border-radius: 16px;
                                padding: 20px;
                                cursor: pointer;
                                transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                                border: 2px solid rgba(59, 130, 246, 0.2);
                                text-align: center;
                                position: relative;
                                overflow: hidden;
                            }

                            .character-choice-card::before {
                                content: '';
                                position: absolute;
                                top: 0;
                                left: -100%;
                                width: 100%;
                                height: 100%;
                                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
                                transition: left 0.5s ease;
                            }

                            .character-choice-card:hover::before {
                                left: 100%;
                            }

                            .character-choice-card:hover {
                                background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
                                border-color: #60a5fa;
                                transform: translateY(-8px) scale(1.02);
                                box-shadow: 0 20px 40px rgba(59, 130, 246, 0.3), 0 0 20px rgba(59, 130, 246, 0.2);
                            }

                            .character-choice-card:active {
                                transform: translateY(-4px) scale(1.01);
                            }

                            .character-image-container {
                                width: 120px;
                                height: 120px;
                                margin: 0 auto 15px;
                                border-radius: 12px;
                                overflow: hidden;
                                background: linear-gradient(135deg, #374151, #1f2937);
                                border: 3px solid rgba(59, 130, 246, 0.3);
                                position: relative;
                                transition: all 0.3s ease;
                            }

                            .character-choice-card:hover .character-image-container {
                                border-color: rgba(255, 255, 255, 0.6);
                                box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
                            }

                            .character-image-container img {
                                width: 100%;
                                height: 100%;
                                object-fit: cover;
                                transition: transform 0.3s ease;
                            }

                            .character-choice-card:hover .character-image-container img {
                                transform: scale(1.1);
                            }

                            .character-overlay {
                                position: absolute;
                                top: 0;
                                left: 0;
                                right: 0;
                                bottom: 0;
                                background: rgba(59, 130, 246, 0.9);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                opacity: 0;
                                transition: opacity 0.3s ease;
                                backdrop-filter: blur(2px);
                            }

                            .character-choice-card:hover .character-overlay {
                                opacity: 1;
                            }

                            .select-text {
                                color: white;
                                font-weight: 700;
                                font-size: 0.9rem;
                                letter-spacing: 1px;
                                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                            }

                            .character-info h4 {
                                color: #f1f5f9;
                                margin-bottom: 12px;
                                font-size: 1.1rem;
                                font-weight: 600;
                                transition: color 0.3s ease;
                            }

                            .character-choice-card:hover .character-info h4 {
                                color: white;
                                text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                            }

                            .character-tags {
                                display: flex;
                                flex-wrap: wrap;
                                gap: 6px;
                                justify-content: center;
                            }

                            .tag {
                                font-size: 0.75rem;
                                padding: 4px 10px;
                                border-radius: 20px;
                                font-weight: 600;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                                transition: all 0.3s ease;
                            }

                            .tag-school { background: #3b82f6; color: white; }
                            .tag-support { background: #10b981; color: white; }
                            .tag-physical { background: #f59e0b; color: white; }
                            .tag-carry { background: #ef4444; color: white; }
                            .tag-solo { background: #8b5cf6; color: white; }
                            .tag-tank { background: #6b7280; color: white; }

                            .character-choice-card:hover .tag {
                                background: rgba(255, 255, 255, 0.9);
                                color: #1e293b;
                                transform: scale(1.05);
                            }

                            .quest-reward-actions {
                                text-align: center;
                                padding-top: 20px;
                                border-top: 1px solid rgba(59, 130, 246, 0.2);
                            }

                            .cancel-button {
                                background: linear-gradient(135deg, #64748b, #475569);
                                color: white;
                                border: none;
                                padding: 14px 28px;
                                border-radius: 12px;
                                cursor: pointer;
                                font-size: 1rem;
                                font-weight: 600;
                                transition: all 0.3s ease;
                                display: inline-flex;
                                align-items: center;
                                gap: 8px;
                                border: 2px solid rgba(148, 163, 184, 0.3);
                            }

                            .cancel-button:hover {
                                background: linear-gradient(135deg, #ef4444, #dc2626);
                                border-color: #fca5a5;
                                transform: translateY(-2px);
                                box-shadow: 0 10px 20px rgba(239, 68, 68, 0.3);
                            }
                        `;
                        document.head.appendChild(styles);
                    }

                    // Add click handlers
                    this.modal.addEventListener('click', (e) => {
                        if (e.target === this.modal) {
                            this.closeModal();
                        }
                    });

                    const characterCards = this.modal.querySelectorAll('.character-choice-card');
                    characterCards.forEach((card, index) => {
                        card.addEventListener('click', () => {
                            const characterId = card.dataset.characterId;
                            const character = characters[index]; // Get the full character object
                            console.log(`[QuestReward] 🖱️ Card clicked - Index: ${index}, CharacterId: "${characterId}", Type: ${typeof characterId}`);
                            console.log(`[QuestReward] 🔍 Card dataset:`, card.dataset);
                            console.log(`[QuestReward] 🔍 Character object:`, character);
                            this.selectCharacter(characterId, questId, character);
                        });
                    });

                    document.body.appendChild(this.modal);
                }

                async selectCharacter(characterId, questId, character) {
                    console.log('[QuestReward] ✅ Player selected character:', characterId);
                    console.log('[QuestReward] ✅ Character object:', character);
                    
                    try {
                        // Award the character
                        const success = await this.awardCharacter(characterId);
                        
                        if (success) {
                            // Clear pending reward
                            await this.clearPendingCharacterReward(questId);
                            
                            // Show success notification using the character object we already have
                            this.showSuccessNotification(`🎉 You've unlocked ${character.name}!`);
                            
                            // Mark quest as claimed (this should already be done by quest manager)
                            console.log('[QuestReward] ✅ Character reward awarded successfully');
                            
                            // Close modal
                            this.closeModal();
                            
                            // Refresh character selector if on that page
                            if (typeof refreshCharacterSelector === 'function') {
                                refreshCharacterSelector();
                            }
                        } else {
                            throw new Error('Failed to award character');
                        }
                        
                    } catch (error) {
                        console.error('[QuestReward] ❌ Error selecting character:', error);
                        this.showErrorNotification('Error awarding character. Please try again.');
                    }
                }

                async awardCharacter(characterId) {
                    console.log(`[QuestReward] 🎁 Awarding character - ID: "${characterId}", Type: ${typeof characterId}`);
                    
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        console.log('[QuestReward] ❌ Firebase not available for character awarding');
                        return false;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        
                        // Get current owned characters
                        const snapshot = await firebaseDatabase.ref(`users/${userId}/ownedCharacters`).once('value');
                        let ownedCharacters = [];
                        
                        if (snapshot.exists()) {
                            const ownedData = snapshot.val();
                            if (Array.isArray(ownedData)) {
                                ownedCharacters = ownedData;
                            } else if (typeof ownedData === 'object') {
                                ownedCharacters = Object.keys(ownedData).filter(key => ownedData[key] === true);
                            }
                        }
                        
                        // Add character if not already owned
                        if (!ownedCharacters.includes(characterId)) {
                            ownedCharacters.push(characterId);
                            await firebaseDatabase.ref(`users/${userId}/ownedCharacters`).set(ownedCharacters);
                            console.log('[QuestReward] ✅ Character added to owned characters:', characterId);
                        }
                        
                        return true;
                    } catch (error) {
                        console.error('[QuestReward] ❌ Error awarding character:', error);
                        return false;
                    }
                }

                async getCharacterData(characterId) {
                    const response = await fetch('characters.json');
                    const charactersData = await response.json();
                    return charactersData[characterId];
                }

                async awardAlternativeReward(questId) {
                    // Award 10 talent points instead
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        return false;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        const talentPointsRef = firebaseDatabase.ref(`users/${userId}/talentPoints`);
                        const snapshot = await talentPointsRef.once('value');
                        const currentPoints = snapshot.exists() ? snapshot.val() : 0;
                        
                        await talentPointsRef.set(currentPoints + 10);
                        this.showSuccessNotification('🌟 Awarded 10 Talent Points as alternative reward!');
                        
                        console.log('[QuestReward] ✅ Awarded 10 talent points as alternative reward');
                        return true;
                    } catch (error) {
                        console.error('[QuestReward] ❌ Error awarding alternative reward:', error);
                        return false;
                    }
                }

                closeModal() {
                    if (this.modal) {
                        this.modal.remove();
                        this.modal = null;
                    }
                }

                removeModal() {
                    if (this.modal) {
                        this.modal.remove();
                        this.modal = null;
                    }
                }

                async checkPendingCharacterReward(questId) {
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        return false;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        const snapshot = await firebaseDatabase.ref(`users/${userId}/pendingCharacterRewards/${questId}`).once('value');
                        return snapshot.exists();
                    } catch (error) {
                        console.error('[QuestReward] Error checking pending reward:', error);
                        return false;
                    }
                }

                async setPendingCharacterReward(questId, questName) {
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        return false;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        await firebaseDatabase.ref(`users/${userId}/pendingCharacterRewards/${questId}`).set({
                            questName: questName,
                            rewardType: 'student_character_choice',
                            timestamp: Date.now()
                        });
                        console.log('[QuestReward] ✅ Set pending character reward for quest:', questId);
                        return true;
                    } catch (error) {
                        console.error('[QuestReward] Error setting pending reward:', error);
                        return false;
                    }
                }

                async clearPendingCharacterReward(questId) {
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        return false;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        await firebaseDatabase.ref(`users/${userId}/pendingCharacterRewards/${questId}`).remove();
                        console.log('[QuestReward] ✅ Cleared pending character reward for quest:', questId);
                        return true;
                    } catch (error) {
                        console.error('[QuestReward] Error clearing pending reward:', error);
                        return false;
                    }
                }

                async checkForPendingRewards() {
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        console.log('[QuestReward] ⏳ Waiting for Firebase authentication...');
                        return false;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        console.log('[QuestReward] 🔍 Checking for pending character rewards...');
                        
                        const snapshot = await firebaseDatabase.ref(`users/${userId}/pendingCharacterRewards`).once('value');
                        
                        if (snapshot.exists()) {
                            const pendingRewards = snapshot.val();
                            const questIds = Object.keys(pendingRewards);
                            
                            if (questIds.length > 0) {
                                console.log(`[QuestReward] 🎁 Found ${questIds.length} pending character reward(s):`, questIds);
                                
                                // Show the first pending reward
                                const firstQuestId = questIds[0];
                                const rewardData = pendingRewards[firstQuestId];
                                
                                console.log(`[QuestReward] 🎯 Showing pending reward for quest: ${rewardData.questName}`);
                                
                                setTimeout(() => {
                                    this.showStudentCharacterChoice(firstQuestId, rewardData.questName);
                                }, 500);
                                
                                return true;
                            }
                        } else {
                            console.log('[QuestReward] ✅ No pending character rewards found');
                        }
                        return false;
                    } catch (error) {
                        console.error('[QuestReward] ❌ Error checking for pending rewards:', error);
                        return false;
                    }
                }

                // Enhanced initialization that waits for Firebase auth
                async initializeAndCheckPendingRewards() {
                    console.log('[QuestReward] 🚀 Initializing quest character choice system...');
                    
                    // Wait for Firebase auth to be ready
                    const maxAttempts = 10;
                    let attempts = 0;
                    
                    while (attempts < maxAttempts) {
                        if (firebaseAuth && firebaseAuth.currentUser && firebaseDatabase) {
                            console.log('[QuestReward] ✅ Firebase ready, checking for pending rewards...');
                            const foundPending = await this.checkForPendingRewards();
                            if (!foundPending) {
                                console.log('[QuestReward] 📝 Ready for new quest completions');
                            }
                            return;
                        }
                        
                        attempts++;
                        console.log(`[QuestReward] ⏳ Waiting for Firebase... (${attempts}/${maxAttempts})`);
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    console.log('[QuestReward] ⚠️ Timeout waiting for Firebase authentication');
                }

                // Manual function to trigger pending reward check
                async checkPendingRewardsNow() {
                    console.log('[QuestReward] 🔄 Manual check for pending rewards...');
                    return await this.checkForPendingRewards();
                }

                // Notification functions
                showSuccessNotification(message) {
                    console.log(`[QuestReward] ✅ SUCCESS: ${message}`);
                    this.createNotificationToast(message, 'success', '✅');
                }

                showErrorNotification(message) {
                    console.error(`[QuestReward] ❌ ERROR: ${message}`);
                    this.createNotificationToast(message, 'error', '❌');
                }

                showInfoNotification(message) {
                    console.log(`[QuestReward] ℹ️ INFO: ${message}`);
                    this.createNotificationToast(message, 'info', 'ℹ️');
                }

                createNotificationToast(message, type, icon) {
                    // Remove any existing notifications
                    const existingToast = document.querySelector('.quest-notification-toast');
                    if (existingToast) {
                        existingToast.remove();
                    }

                    // Create notification toast
                    const toast = document.createElement('div');
                    toast.className = `quest-notification-toast quest-notification-${type}`;
                    toast.innerHTML = `
                        <div class="quest-notification-content">
                            <span class="quest-notification-icon">${icon}</span>
                            <span class="quest-notification-message">${message}</span>
                        </div>
                    `;

                    // Add styles if not already present
                    if (!document.querySelector('#quest-notification-styles')) {
                        const styles = document.createElement('style');
                        styles.id = 'quest-notification-styles';
                        styles.textContent = `
                            .quest-notification-toast {
                                position: fixed;
                                top: 20px;
                                right: 20px;
                                z-index: 10001;
                                min-width: 300px;
                                max-width: 500px;
                                padding: 16px 20px;
                                border-radius: 12px;
                                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                                backdrop-filter: blur(10px);
                                animation: questToastSlideIn 0.3s ease-out;
                                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            }

                            .quest-notification-success {
                                background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.9));
                                border: 1px solid rgba(16, 185, 129, 0.5);
                                color: white;
                            }

                            .quest-notification-error {
                                background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9));
                                border: 1px solid rgba(239, 68, 68, 0.5);
                                color: white;
                            }

                            .quest-notification-info {
                                background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
                                border: 1px solid rgba(59, 130, 246, 0.5);
                                color: white;
                            }

                            .quest-notification-content {
                                display: flex;
                                align-items: center;
                                gap: 12px;
                            }

                            .quest-notification-icon {
                                font-size: 1.2rem;
                                flex-shrink: 0;
                            }

                            .quest-notification-message {
                                font-size: 1rem;
                                font-weight: 500;
                                line-height: 1.4;
                            }

                            @keyframes questToastSlideIn {
                                from {
                                    opacity: 0;
                                    transform: translateX(100%) scale(0.9);
                                }
                                to {
                                    opacity: 1;
                                    transform: translateX(0) scale(1);
                                }
                            }

                            @keyframes questToastSlideOut {
                                from {
                                    opacity: 1;
                                    transform: translateX(0) scale(1);
                                }
                                to {
                                    opacity: 0;
                                    transform: translateX(100%) scale(0.9);
                                }
                            }
                        `;
                        document.head.appendChild(styles);
                    }

                    // Add to page
                    document.body.appendChild(toast);

                    // Auto-remove after 4 seconds
                    setTimeout(() => {
                        toast.style.animation = 'questToastSlideOut 0.3s ease-in';
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.remove();
                            }
                        }, 300);
                    }, 4000);
                }
            }

            // Create global instance
            window.questCharacterChoice = new QuestCharacterChoiceSystem();

            // Listen for quest completion events
            window.addEventListener('questCompleted', async (event) => {
                const { quest } = event.detail;
                
                if (quest.reward.type === 'student_character_choice') {
                    console.log('[QuestReward] 🎓 Quest completed with student character choice reward:', quest.name);
                    
                    // Set pending reward first
                    await window.questCharacterChoice.setPendingCharacterReward(quest.id, quest.name);
                    
                    // Then show the choice modal
                    await window.questCharacterChoice.showStudentCharacterChoice(quest.id, quest.name);
                }
            });

            // Enhanced pending rewards checking on page load
            document.addEventListener('DOMContentLoaded', () => {
                console.log('[QuestReward] 📄 Page loaded, setting up pending rewards check...');
                
                if (window.questCharacterChoice) {
                    window.questCharacterChoice.initializeAndCheckPendingRewards();
                }
            });

            // Also check when Firebase auth state changes
            firebaseAuth.onAuthStateChanged((user) => {
                if (user && window.questCharacterChoice) {
                    console.log('[QuestReward] 🔐 User authenticated, checking for pending rewards...');
                    setTimeout(() => {
                        window.questCharacterChoice.checkForPendingRewards();
                    }, 1000);
                }
            });

            // Window load as backup
            window.addEventListener('load', () => {
                setTimeout(() => {
                    if (window.questCharacterChoice && firebaseAuth.currentUser) {
                        console.log('[QuestReward] 🔄 Window loaded, backup pending rewards check...');
                        window.questCharacterChoice.checkForPendingRewards();
                    }
                }, 3000);
            });

            // Global function for manual checking
            window.checkPendingCharacterRewards = () => {
                if (window.questCharacterChoice) {
                    return window.questCharacterChoice.checkPendingRewardsNow();
                } else {
                    console.log('[QuestReward] ❌ Quest character choice system not initialized');
                    return false;
                }
            };

            // Admin Console Functions - Only Available to FishB0nes98
            class AdminConsole {
                constructor() {
                    this.isAdmin = false;
                    this.adminUsername = 'FishB0nes98';
                    this.checkAdminStatus();
                }

                async checkAdminStatus() {
                    if (!firebaseAuth.currentUser || !firebaseDatabase) {
                        return;
                    }

                    try {
                        const userId = firebaseAuth.currentUser.uid;
                        const userSnapshot = await firebaseDatabase.ref(`users/${userId}/username`).once('value');
                        
                        if (userSnapshot.exists() && userSnapshot.val() === this.adminUsername) {
                            this.isAdmin = true;
                            this.setupAdminFunctions();
                            console.log('🔐 Admin console activated for FishB0nes98');
                        }
                    } catch (error) {
                        console.error('Error checking admin status:', error);
                    }
                }

                setupAdminFunctions() {
                    if (!this.isAdmin) return;

                    // Display admin debug commands help
                    this.showAdminDebugHelp();

                    // Quest Management Functions
                    window.adminAddHealingQuest = async () => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        console.log('[ADMIN] 🎯 Adding Healing Quest...');
                        const result = await window.debugAddHealingQuest();
                        if (result.success) {
                            console.log('[ADMIN] ✅ Healing Quest added successfully!');
                        } else {
                            console.error('[ADMIN] ❌ Failed to add healing quest:', result.error);
                        }
                        return result;
                    };

                    // Protect all existing debug functions with admin check
                    this.wrapDebugFunctionsWithAdminCheck();

                    window.adminViewUserQuests = async (targetUserId = null) => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        const userId = targetUserId || firebaseAuth.currentUser.uid;
                        console.log(`[ADMIN] 👀 Viewing quests for user: ${userId}`);
                        
                        try {
                            const progressSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUEST`).once('value');
                            const completedSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUESTDONE`).once('value');
                            const claimedSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUESTCLAIMED`).once('value');
                            
                            const progress = progressSnapshot.exists() ? progressSnapshot.val() : {};
                            const completed = completedSnapshot.exists() ? completedSnapshot.val() : {};
                            const claimed = claimedSnapshot.exists() ? claimedSnapshot.val() : {};
                            
                            console.log('[ADMIN] 📊 Quest Progress:', progress);
                            console.log('[ADMIN] ✅ Completed Quests:', completed);
                            console.log('[ADMIN] 🎁 Claimed Quests:', claimed);
                            
                            return { progress, completed, claimed };
                        } catch (error) {
                            console.error('[ADMIN] ❌ Error viewing user quests:', error);
                            return { error: error.message };
                        }
                    };

                    window.adminCompleteQuest = async (questId, targetUserId = null) => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        const userId = targetUserId || firebaseAuth.currentUser.uid;
                        console.log(`[ADMIN] 🎉 Force completing quest ${questId} for user: ${userId}`);
                        
                        try {
                            const quest = window.questManager.questRegistry.find(q => q.id === questId);
                            if (!quest) {
                                console.error(`[ADMIN] ❌ Quest ${questId} not found`);
                                return { error: `Quest ${questId} not found` };
                            }
                            
                            const updates = {};
                            updates[`users/${userId}/RAIDQUEST/${questId}`] = quest.target;
                            updates[`users/${userId}/RAIDQUESTDONE/${questId}`] = true;
                            
                            await firebaseDatabase.ref().update(updates);
                            console.log(`[ADMIN] ✅ Quest ${questId} completed for user ${userId}`);
                            
                            return { success: true, questId, userId };
                        } catch (error) {
                            console.error('[ADMIN] ❌ Error completing quest:', error);
                            return { error: error.message };
                        }
                    };

                    window.adminSetQuestProgress = async (questId, progress, targetUserId = null) => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        const userId = targetUserId || firebaseAuth.currentUser.uid;
                        console.log(`[ADMIN] 📈 Setting quest ${questId} progress to ${progress} for user: ${userId}`);
                        
                        try {
                            await firebaseDatabase.ref(`users/${userId}/RAIDQUEST/${questId}`).set(progress);
                            console.log(`[ADMIN] ✅ Quest progress updated`);
                            
                            return { success: true, questId, progress, userId };
                        } catch (error) {
                            console.error('[ADMIN] ❌ Error setting quest progress:', error);
                            return { error: error.message };
                        }
                    };

                    window.adminResetQuest = async (questId, targetUserId = null) => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        const userId = targetUserId || firebaseAuth.currentUser.uid;
                        console.log(`[ADMIN] 🔄 Resetting quest ${questId} for user: ${userId}`);
                        
                        try {
                            const updates = {};
                            updates[`users/${userId}/RAIDQUEST/${questId}`] = null;
                            updates[`users/${userId}/RAIDQUESTDONE/${questId}`] = null;
                            updates[`users/${userId}/RAIDQUESTCLAIMED/${questId}`] = null;
                            
                            await firebaseDatabase.ref().update(updates);
                            console.log(`[ADMIN] ✅ Quest ${questId} reset for user ${userId}`);
                            
                            return { success: true, questId, userId };
                        } catch (error) {
                            console.error('[ADMIN] ❌ Error resetting quest:', error);
                            return { error: error.message };
                        }
                    };

                    window.adminGrantCharacter = async (characterId, targetUserId = null) => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        const userId = targetUserId || firebaseAuth.currentUser.uid;
                        console.log(`[ADMIN] 🎁 Granting character ${characterId} to user: ${userId}`);
                        
                        try {
                            const snapshot = await firebaseDatabase.ref(`users/${userId}/ownedCharacters`).once('value');
                            let ownedCharacters = [];
                            
                            if (snapshot.exists()) {
                                const ownedData = snapshot.val();
                                if (Array.isArray(ownedData)) {
                                    ownedCharacters = ownedData;
                                } else if (typeof ownedData === 'object') {
                                    ownedCharacters = Object.keys(ownedData).filter(key => ownedData[key] === true);
                                }
                            }
                            
                            if (!ownedCharacters.includes(characterId)) {
                                ownedCharacters.push(characterId);
                                await firebaseDatabase.ref(`users/${userId}/ownedCharacters`).set(ownedCharacters);
                                console.log(`[ADMIN] ✅ Character ${characterId} granted to user ${userId}`);
                                return { success: true, characterId, userId };
                            } else {
                                console.log(`[ADMIN] ℹ️ User ${userId} already owns character ${characterId}`);
                                return { success: true, message: 'Already owned', characterId, userId };
                            }
                        } catch (error) {
                            console.error('[ADMIN] ❌ Error granting character:', error);
                            return { error: error.message };
                        }
                    };

                    window.adminShowStudentCharacterChoice = async (questId = 'heal_100k') => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        console.log('[ADMIN] 🎓 Showing Student character choice modal...');
                        
                        try {
                            await window.questCharacterChoice.showStudentCharacterChoice(questId, 'Admin Test - Master Healer');
                            return { success: true };
                        } catch (error) {
                            console.error('[ADMIN] ❌ Error showing character choice:', error);
                            return { error: error.message };
                        }
                    };

                    window.adminListAllQuests = () => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        console.log('[ADMIN] 📋 Available Quests:');
                        if (window.questManager && window.questManager.questRegistry) {
                            window.questManager.questRegistry.forEach(quest => {
                                console.log(`• ${quest.id}: ${quest.name} (${quest.type}) - Target: ${quest.target} ${quest.progressKey}`);
                            });
                            return window.questManager.questRegistry;
                        } else {
                            console.log('[ADMIN] ❌ Quest manager not initialized');
                            return { error: 'Quest manager not initialized' };
                        }
                    };

                    window.adminHelp = () => {
                        if (!this.isAdmin) return this.accessDenied();
                        
                        console.log(`
🔐 ADMIN CONSOLE - FishB0nes98 Only

📋 QUEST MANAGEMENT:
• adminAddHealingQuest() - Add the healing quest to Firebase
• adminListAllQuests() - List all available quests
• adminViewUserQuests(userId?) - View quest progress for user
• adminCompleteQuest(questId, userId?) - Force complete a quest
• adminSetQuestProgress(questId, progress, userId?) - Set quest progress
• adminResetQuest(questId, userId?) - Reset quest progress

🎁 CHARACTER MANAGEMENT:
• adminGrantCharacter(characterId, userId?) - Grant character to user
• adminShowStudentCharacterChoice() - Test character choice modal

📝 NOTES:
• userId is optional - defaults to current user
• Quest IDs: 'heal_100k' for healing quest
• Student character IDs: '0'=Schoolboy Shoma, '7'=Schoolgirl Kokoro, '8'=Schoolboy Siegfried, 
  '9'=Schoolgirl Julia, '10'=Schoolgirl Ayane, '11'=Schoolgirl Elphelt

Example: adminCompleteQuest('heal_100k') - Complete healing quest for yourself
Example: adminGrantCharacter('8', 'someUserId') - Grant Schoolboy Siegfried to user
                        `);
                    };

                    // Auto-show help
                    setTimeout(() => {
                        window.adminHelp();
                    }, 1000);

                    // Manual command to show all debug functions
                    window.showAdminDebugCommands = () => {
                        if (!this.isAdmin) return this.accessDenied();
                        this.showAdminDebugHelp();
                    };
                }

                showAdminDebugHelp() {
                    setTimeout(() => {
                        console.log('%c🔐 ADMIN DEBUG CONSOLE - FishB0nes98 Only 🔐', 'background: #ff0000; color: white; padding: 10px; border-radius: 5px; font-weight: bold;');
                        console.log('%cAvailable admin debug functions:', 'color: #ff6b6b; font-weight: bold;');
                        console.log('%c📋 QUEST FUNCTIONS:', 'color: #ffbd00; font-weight: bold;');
                        console.log('%c  debugViewQuestsInDatabase() %c- View current quests in database', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugAddHealingQuest() %c- Add healing quest (100K HP → Student choice)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugAdd006HealingQuest() %c- Same as above (alias)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c🎯 ADD INDIVIDUAL QUESTS:', 'color: #8b5cf6; font-weight: bold;');
                        console.log('%c  debugAdd001TurnMaster() %c- Turn Master (200 turns → Bridget)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugAdd002VictoryStreak() %c- Victory Streak (10 wins → Angel)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugAdd003FirstSteps() %c- First Steps (5 battles → Elite Stage)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugAdd004StorySeeker() %c- Story Seeker (3 stories → Hidden Chronicles)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugAdd005DamageDealer() %c- Damage Dealer (10k damage → Morrigan)', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c🔧 OTHER QUEST TOOLS:', 'color: #8b5cf6; font-weight: bold;');
                        console.log('%c  debugAddQuestsToFirebase() %c- Add all quests at once', 'color: #fb923c;', 'color: #9ca3af;');
                        console.log('%c  debugRemoveQuest("001") %c- Remove specific quest by ID', 'color: #f87171;', 'color: #9ca3af;');
                        console.log('%c  debugClearAllQuests() %c- Delete all quests (with confirmation)', 'color: #f87171;', 'color: #9ca3af;');
                        console.log('%c🔍 QUEST DEBUGGING:', 'color: #22d3ee; font-weight: bold;');
                        console.log('%c  debugCheckQuestProgress("001") %c- Check specific quest progress', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugSimulateTurns(5) %c- Simulate turns for testing', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugCompleteQuest("001") %c- Force complete quest for testing', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugClaimQuest("001") %c- Manually claim quest reward', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c🔓 UNLOCK FUNCTIONS:', 'color: #ffbd00; font-weight: bold;');
                        console.log('%c  debugUnlockAllCharacters() %c- Temporarily unlock all characters', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugUnlockAllStages() %c- Temporarily unlock all stages', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugUnlockAllStories() %c- Temporarily unlock all stories', 'color: #4ade80;', 'color: #9ca3af;');
                        console.log('%c  debugUnlockEverything() %c- Unlock everything at once', 'color: #ff6b6b;', 'color: #9ca3af;');
                        console.log('%c  debugRestoreOwnedCharacters() %c- Restore original ownership', 'color: #ffbd00;', 'color: #9ca3af;');
                        console.log('%c⚠️  Character unlocks are temporary and reset on page refresh', 'color: #fb923c;');
                        console.log('%c🎯  Quest database changes are PERMANENT', 'color: #fb923c; font-weight: bold;');
                        console.log('%c🔐  All debug functions are ADMIN-ONLY for FishB0nes98', 'color: #ff0000; font-weight: bold;');
                    }, 2000);
                }

                wrapDebugFunctionsWithAdminCheck() {
                    // List of all debug functions to protect
                    const debugFunctions = [
                        'debugViewQuestsInDatabase',
                        'debugAdd001TurnMaster',
                        'debugAdd002VictoryStreak', 
                        'debugAdd003FirstSteps',
                        'debugAdd004StorySeeker',
                        'debugAdd005DamageDealer',
                        'debugAddQuestsToFirebase',
                        'debugRemoveQuest',
                        'debugClearAllQuests',
                        'debugCheckQuestProgress',
                        'debugSimulateTurns',
                        'debugCompleteQuest',
                        'debugClaimQuest',
                        'debugUnlockAllCharacters',
                        'debugUnlockAllStages',
                        'debugUnlockAllStories',
                        'debugUnlockEverything',
                        'debugRestoreOwnedCharacters',
                        'debugAddHealingQuest',
                        'debugAdd006HealingQuest',
                        'debugAddSingleQuest'
                    ];

                    // Store original functions and wrap them with admin check
                    debugFunctions.forEach(funcName => {
                        if (window[funcName]) {
                            const originalFunc = window[funcName];
                            window[funcName] = (...args) => {
                                if (!this.isAdmin) {
                                    return this.accessDenied();
                                }
                                return originalFunc.apply(this, args);
                            };
                        }
                    });

                    console.log(`[ADMIN] 🔒 Protected ${debugFunctions.length} debug functions with admin access control`);
                }

                accessDenied() {
                    console.error('🚫 Access Denied: Admin functions are only available to FishB0nes98');
                    return { error: 'Access denied - Admin only' };
                }
            }

            // Initialize admin console
            window.adminConsole = new AdminConsole();

            // Global function to show debug commands (admin only)
            window.showDebugCommands = async () => {
                // Force re-check admin status
                await window.checkAdminStatus();
                
                if (window.adminConsole && window.adminConsole.isAdmin) {
                    window.adminConsole.showAdminDebugHelp();
                } else {
                    console.log('%c🚫 Access Denied', 'color: #ff0000; font-weight: bold;');
                    console.log('%cDebug commands are only available to FishB0nes98', 'color: #ff6b6b;');
                    console.log('%cMake sure you are logged in to Firebase with the correct account', 'color: #9ca3af;');
                }
            };

            // Add a function to manually check admin status
            window.checkAdminStatus = async () => {
                if (!firebaseAuth.currentUser) {
                    console.log('%c❌ Not logged in to Firebase', 'color: #ff6b6b;');
                    return false;
                }

                try {
                    const userId = firebaseAuth.currentUser.uid;
                    const userSnapshot = await firebaseDatabase.ref(`users/${userId}/username`).once('value');
                    const username = userSnapshot.exists() ? userSnapshot.val() : 'Unknown';
                    
                    console.log(`%cCurrent user: ${username}`, 'color: #4ade80;');
                    console.log(`%cUser ID: ${userId}`, 'color: #9ca3af;');
                    
                    if (username === 'FishB0nes98') {
                        console.log('%c✅ Admin access confirmed!', 'color: #00ff00; font-weight: bold;');
                        if (window.adminConsole) {
                            window.adminConsole.isAdmin = true;
                            window.adminConsole.setupAdminFunctions();
                        }
                        return true;
                    } else {
                        console.log('%c❌ Not an admin user', 'color: #ff6b6b;');
                        return false;
                    }
                } catch (error) {
                    console.error('%cError checking admin status:', 'color: #ff6b6b;', error);
                    return false;
                }
            };

            // Function to check and complete "To The Hell We Go" story quest
            async function checkAndCompleteHellStoryQuest(userId) {
                try {
                    console.log('[CharacterSelector] Checking hell story quest completion...');
                    
                    // Check if quest manager is available and initialized
                    if (!window.questManager || !window.questManager.initialized) {
                        console.log('[CharacterSelector] Quest manager not available, skipping hell story quest check');
                        return;
                    }
                    
                    const questId = 'complete_to_the_hell_we_go_story';
                    
                    // Check quest progress from Firebase - story quests are in main questProgress path
                    console.log(`[CharacterSelector] Fetching Firebase data for quest: ${questId}`);
                    const progressSnapshot = await firebaseDatabase.ref(`users/${userId}/questProgress/${questId}`).once('value');
                    const completedSnapshot = await firebaseDatabase.ref(`users/${userId}/completedQuests/${questId}`).once('value');
                    console.log(`[CharacterSelector] Firebase data fetched successfully`);
                    
                    // Debug: Check what quest data exists in Firebase
                    console.log(`[CharacterSelector] Progress snapshot exists:`, progressSnapshot.exists());
                    console.log(`[CharacterSelector] Progress value:`, progressSnapshot.exists() ? progressSnapshot.val() : 'No data');
                    
                    // Debug: Let's also check if there are any similar quest IDs in Firebase
                    const allProgressSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUEST`).once('value');
                    if (allProgressSnapshot.exists()) {
                        const allProgress = allProgressSnapshot.val();
                        const allQuestIds = Object.keys(allProgress);
                        const storyRelatedIds = allQuestIds.filter(id => id.includes('story') || id.includes('hell') || id.includes('complete'));
                        console.log(`[CharacterSelector] Story/hell-related quest IDs in Firebase:`, storyRelatedIds);
                        
                        // Show some progress values for debugging
                        storyRelatedIds.forEach(id => {
                            console.log(`[CharacterSelector] ${id}: ${allProgress[id]}`);
                        });
                    }
                    
                    // Find the quest definition to get the target
                    let quest = null;
                    let target = 1; // Default target for story completion quests
                    
                    // Try to find the quest in different ways
                    if (window.questManager.questRegistry) {
                        if (Array.isArray(window.questManager.questRegistry)) {
                            quest = window.questManager.questRegistry.find(q => q.id === questId);
                        } else if (typeof window.questManager.questRegistry === 'object') {
                            quest = window.questManager.questRegistry[questId];
                        }
                    }
                    
                    // If we found the quest, use its target, otherwise use default
                    if (quest && quest.target) {
                        target = quest.target;
                    }
                    
                    console.log(`[CharacterSelector] Quest found:`, quest);
                    console.log(`[CharacterSelector] Using target: ${target}`);
                    
                    // Debug: Log quest registry structure to understand what's available
                    console.log(`[CharacterSelector] Quest registry type:`, typeof window.questManager.questRegistry);
                    console.log(`[CharacterSelector] Quest registry is array:`, Array.isArray(window.questManager.questRegistry));
                    
                    // Debug: Look for hell-related quests
                    if (window.questManager.questRegistry) {
                        if (Array.isArray(window.questManager.questRegistry)) {
                            const hellQuests = window.questManager.questRegistry.filter(q => 
                                q.id && (q.id.includes('hell') || q.id.includes('story') || q.name && q.name.toLowerCase().includes('hell'))
                            );
                            console.log(`[CharacterSelector] Found hell-related quests:`, hellQuests);
                        } else if (typeof window.questManager.questRegistry === 'object') {
                            const questIds = Object.keys(window.questManager.questRegistry);
                            const hellQuestIds = questIds.filter(id => id.includes('hell') || id.includes('story'));
                            console.log(`[CharacterSelector] Available quest IDs:`, questIds.slice(0, 10), '... (showing first 10)');
                            console.log(`[CharacterSelector] Hell-related quest IDs:`, hellQuestIds);
                        }
                    }
                    
                    // Debug: Check what quest data exists in Firebase (moved outside the conditional)
                    console.log(`[CharacterSelector] Progress snapshot exists:`, progressSnapshot.exists());
                    console.log(`[CharacterSelector] Progress value:`, progressSnapshot.exists() ? progressSnapshot.val() : 'No data');
                    
                    // Debug: Let's also check if there are any similar quest IDs in Firebase
                    const allQuestProgressSnapshot = await firebaseDatabase.ref(`users/${userId}/questProgress`).once('value');
                    if (allQuestProgressSnapshot.exists()) {
                        const allProgress = allQuestProgressSnapshot.val();
                        const allQuestIds = Object.keys(allProgress);
                        const storyRelatedIds = allQuestIds.filter(id => id.includes('story') || id.includes('hell') || id.includes('complete'));
                        console.log(`[CharacterSelector] Story/hell-related quest IDs in Firebase:`, storyRelatedIds);
                        
                        // Show some progress values for debugging
                        storyRelatedIds.forEach(id => {
                            console.log(`[CharacterSelector] ${id}: ${allProgress[id]}`);
                        });
                    } else {
                        console.log(`[CharacterSelector] No questProgress data found in Firebase`);
                    }
                    
                    if (progressSnapshot.exists()) {
                        const progress = progressSnapshot.val();
                        const isAlreadyCompleted = completedSnapshot.exists() && completedSnapshot.val();
                        
                        console.log(`[CharacterSelector] Hell story quest progress: ${progress}/${target}, completed: ${isAlreadyCompleted}`);
                        
                        // If progress reaches target and not already completed, complete it
                        if (progress >= target && !isAlreadyCompleted) {
                            console.log('[CharacterSelector] Hell story quest is at target, completing it...');
                            
                            // Use the quest manager's completeQuest method to handle rewards properly
                            if (window.questManager && typeof window.questManager.completeQuest === 'function') {
                                try {
                                    await window.questManager.completeQuest(questId);
                                    console.log('[CharacterSelector] ✅ Hell story quest completed with rewards via quest manager!');
                                } catch (error) {
                                    console.error('[CharacterSelector] Error completing quest via quest manager:', error);
                                    // Fallback to manual completion
                                    await firebaseDatabase.ref(`users/${userId}/completedQuests/${questId}`).set(true);
                                    console.log('[CharacterSelector] ✅ Hell story quest completed manually (fallback)');
                                }
                            } else {
                                // Fallback to manual completion if quest manager not available
                                await firebaseDatabase.ref(`users/${userId}/completedQuests/${questId}`).set(true);
                                console.log('[CharacterSelector] ✅ Hell story quest completed manually (quest manager not available)');
                            }
                            
                            // Show a notification if possible
                            if (typeof showTooltip === 'function') {
                                showTooltip('📚 "To The Hell We Go" story quest completed!');
                            }
                            
                            // Refresh the quest UI if available
                            if (window.questUIManager && typeof window.questUIManager.refreshQuestPanel === 'function') {
                                window.questUIManager.refreshQuestPanel();
                            }
                        } else if (isAlreadyCompleted) {
                            console.log('[CharacterSelector] Hell story quest already completed');
                        } else {
                            console.log(`[CharacterSelector] Hell story quest not ready for completion (${progress}/${target})`);
                        }
                    } else {
                        console.log('[CharacterSelector] Hell story quest progress not found in Firebase or quest not ready for completion');
                        if (!quest) {
                            console.log('[CharacterSelector] Hell story quest definition not found in quest registry, using default target');
                        }
                    }
                } catch (error) {
                    console.error('[CharacterSelector] Error checking/completing hell story quest:', error);
                }
            }

            // Global function to manually complete a quest that's at its target
            window.manuallyCompleteQuest = async function(questId) {
                try {
                    console.log(`[CharacterSelector] Manually completing quest: ${questId}`);
                    
                    if (!firebaseAuth.currentUser) {
                        console.error('[CharacterSelector] User not authenticated');
                        return { success: false, error: 'User not authenticated' };
                    }
                    
                    const userId = firebaseAuth.currentUser.uid;
                    
                    // Check current progress (use questProgress for story quests, RAIDQUEST for raid quests)
                    let progressSnapshot, completedSnapshot;
                    
                    if (questId.includes('story') || questId.includes('complete_')) {
                        // Story completion quests use questProgress path
                        progressSnapshot = await firebaseDatabase.ref(`users/${userId}/questProgress/${questId}`).once('value');
                        completedSnapshot = await firebaseDatabase.ref(`users/${userId}/completedQuests/${questId}`).once('value');
                    } else {
                        // Regular raid quests use RAIDQUEST path
                        progressSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUEST/${questId}`).once('value');
                        completedSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUESTDONE/${questId}`).once('value');
                    }
                    
                    if (progressSnapshot.exists()) {
                        const progress = progressSnapshot.val();
                        const isAlreadyCompleted = completedSnapshot.exists() && completedSnapshot.val();
                        
                        // Find the quest definition to get target
                        let quest = null;
                        let target = 1;
                        
                        if (window.questManager && window.questManager.questRegistry) {
                            if (Array.isArray(window.questManager.questRegistry)) {
                                quest = window.questManager.questRegistry.find(q => q.id === questId);
                            } else if (typeof window.questManager.questRegistry === 'object') {
                                quest = window.questManager.questRegistry[questId];
                            }
                        }
                        
                        if (quest && quest.target) {
                            target = quest.target;
                        }
                        
                        console.log(`[CharacterSelector] Quest ${questId}: progress=${progress}, target=${target}, completed=${isAlreadyCompleted}`);
                        
                        if (progress >= target && !isAlreadyCompleted) {
                            // Use quest manager's completeQuest method for proper reward handling
                            if (window.questManager && typeof window.questManager.completeQuest === 'function') {
                                try {
                                    await window.questManager.completeQuest(questId);
                                    console.log(`[CharacterSelector] ✅ Quest ${questId} completed with rewards via quest manager!`);
                                } catch (error) {
                                    console.error(`[CharacterSelector] Error completing quest ${questId} via quest manager:`, error);
                                    // Fallback to manual completion
                                    if (questId.includes('story') || questId.includes('complete_')) {
                                        await firebaseDatabase.ref(`users/${userId}/completedQuests/${questId}`).set(true);
                                    } else {
                                        const updates = {};
                                        updates[`users/${userId}/RAIDQUESTDONE/${questId}`] = true;
                                        updates[`users/${userId}/RAIDQUEST/${questId}`] = target;
                                        await firebaseDatabase.ref().update(updates);
                                    }
                                }
                            } else {
                                // Fallback to manual completion if quest manager not available
                                if (questId.includes('story') || questId.includes('complete_')) {
                                    await firebaseDatabase.ref(`users/${userId}/completedQuests/${questId}`).set(true);
                                } else {
                                    const updates = {};
                                    updates[`users/${userId}/RAIDQUESTDONE/${questId}`] = true;
                                    updates[`users/${userId}/RAIDQUEST/${questId}`] = target;
                                    await firebaseDatabase.ref().update(updates);
                                }
                                
                                // Update quest manager manually
                                if (window.questManager && window.questManager.completedQuests) {
                                    window.questManager.completedQuests.add(questId);
                                }
                            }
                            
                            console.log(`[CharacterSelector] ✅ Quest ${questId} completed successfully!`);
                            
                            // Refresh UI
                            if (window.questUIManager && typeof window.questUIManager.refreshQuestPanel === 'function') {
                                window.questUIManager.refreshQuestPanel();
                            }
                            
                            if (typeof showTooltip === 'function') {
                                showTooltip(`📚 Quest "${quest?.name || questId}" completed!`);
                            }
                            
                            return { success: true, message: `Quest ${questId} completed` };
                        } else if (isAlreadyCompleted) {
                            console.log(`[CharacterSelector] Quest ${questId} already completed`);
                            return { success: false, error: 'Quest already completed' };
                        } else {
                            console.log(`[CharacterSelector] Quest ${questId} not ready for completion (${progress}/${target})`);
                            return { success: false, error: `Quest not ready for completion (${progress}/${target})` };
                        }
                    } else {
                        console.log(`[CharacterSelector] No progress data found for quest ${questId}`);
                        return { success: false, error: 'No progress data found' };
                    }
                } catch (error) {
                    console.error(`[CharacterSelector] Error manually completing quest ${questId}:`, error);
                    return { success: false, error: error.message };
                }
            };

            // Convenience function to complete the hell story quest specifically
            window.completeHellStoryQuest = async function() {
                return await window.manuallyCompleteQuest('complete_to_the_hell_we_go_story');
            };

            // Debug function to see all available quest progress data
            window.debugShowAllQuestProgress = async function() {
                try {
                    if (!firebaseAuth.currentUser) {
                        console.error('User not authenticated');
                        return;
                    }
                    
                    const userId = firebaseAuth.currentUser.uid;
                    console.log(`[Debug] Fetching all quest progress for user: ${userId}`);
                    
                    // Get all quest progress data
                    const progressSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUEST`).once('value');
                    const completedSnapshot = await firebaseDatabase.ref(`users/${userId}/RAIDQUESTDONE`).once('value');
                    
                    if (progressSnapshot.exists()) {
                        const allProgress = progressSnapshot.val();
                        const allQuestIds = Object.keys(allProgress);
                        
                        console.log(`[Debug] Found ${allQuestIds.length} quests with progress data:`);
                        
                        // Filter for story/hell/complete related quests
                        const storyRelated = allQuestIds.filter(id => 
                            id.includes('story') || 
                            id.includes('hell') || 
                            id.includes('complete') ||
                            id.includes('conquer') ||
                            id.toLowerCase().includes('hell')
                        );
                        
                        console.log(`[Debug] Story/Hell-related quest IDs:`, storyRelated);
                        
                        // Show progress for each story-related quest
                        storyRelated.forEach(questId => {
                            const progress = allProgress[questId];
                            const isCompleted = completedSnapshot.exists() && completedSnapshot.val()[questId];
                            console.log(`[Debug] ${questId}: progress=${progress}, completed=${isCompleted}`);
                        });
                        
                        // Show ALL quest IDs for reference
                        console.log(`[Debug] All quest IDs:`, allQuestIds.sort());
                        
                        return {
                            allQuestIds,
                            storyRelated,
                            progressData: allProgress
                        };
                    } else {
                        console.log('[Debug] No quest progress data found');
                        return null;
                    }
                } catch (error) {
                    console.error('[Debug] Error fetching quest progress:', error);
                    return null;
                }
            };

        });
    </script>

    <!-- Changelog Modal -->
    <div class="changelog-modal" id="changelog-modal">
        <div class="changelog-content">
            <div class="changelog-header">
                <h1 class="changelog-title">
                    🚀 Patch Notes
                    <span class="changelog-version">v0.2</span>
                </h1>
                <p class="changelog-subtitle">Schoolgirl Julia Balance Adjustments</p>
                <button class="changelog-close" onclick="hideChangelog()">&times;</button>
            </div>
            
            <div class="changelog-body">
                <div class="changelog-section">
                    <h3>
                        <svg class="notes-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                        </svg>
                        Character Balance Changes
                    </h3>
                    
                    <div class="character-changes julia">
                        <div class="character-name">
                            <span class="character-emoji">💚</span>
                            <strong>Schoolgirl Julia - Healing Kick (Q) Nerf</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Julia's Healing Kick was significantly overpowered, providing excessive healing output that made encounters trivial. In testing, the ability healed 15.4k over 25 turns while dealing 8.1k damage, creating an unsustainable power level.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Mana Cost:</strong> Increased <span class="change-arrow">60 → 80</span> mana
                            </li>
                            <li class="change-item">
                                <strong>Cooldown:</strong> Increased <span class="change-arrow">1 → 2</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Healing Efficiency:</strong> Reduced <span class="change-arrow">65% → 40%</span> of total damage dealt
                            </li>
                        </ul>
                        <div style="font-size: 0.8rem; color: var(--neutral-400); margin-top: 8px; font-style: italic;">
                            <strong>Impact:</strong> These changes will require more strategic use of Julia's healing ability while still maintaining her role as a hybrid damage/support character. The increased mana cost and cooldown prevent spam usage, while the reduced healing efficiency brings her in line with other support characters.
                        </div>
                    </div>

                    <div class="character-changes kokoro">
                        <div class="character-name">
                            <span class="character-emoji">💚</span>
                            <strong>Schoolgirl Kokoro - Silencing Ring (W) Enhancement</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Silencing Ring was providing limited utility as a pure damage reduction debuff. Adding a damage-over-time component makes it more impactful and creates meaningful pressure on enemies.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>DOT Effect:</strong> Now deals <span class="change-highlight">90 damage per turn</span> for the duration (6 turns)
                            </li>
                            <li class="change-item">
                                <strong>Total Damage:</strong> Can deal up to <span class="change-highlight">540 damage</span> over full duration
                            </li>
                            <li class="change-item">
                                <strong>Visual Effects:</strong> Added new DOT damage VFX with energy drain particles
                            </li>
                            <li class="change-item">
                                <strong>Status Indicator:</strong> Removed persistent status icon for cleaner UI
                            </li>
                        </ul>
                        <div style="font-size: 0.8rem; color: var(--neutral-400); margin-top: 8px; font-style: italic;">
                            <strong>Impact:</strong> Silencing Ring now serves as both a damage mitigation tool and a significant damage source, making Kokoro more versatile in both support and offensive roles. The DOT effect provides consistent pressure while maintaining the original damage reduction utility.
                        </div>
                    </div>

                    <div class="character-changes multiple">
                        <div class="character-name">
                            <span class="character-emoji">⚖️</span>
                            <strong>Additional Balance Changes</strong>
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>⚾ Schoolboy Shoma:</strong> Boink stun chance <span class="change-arrow">35% → 40%</span>, mana cost <span class="change-arrow">40 → 45</span>, Physical Damage <span class="change-arrow">210 → 220</span>
                            </li>
                            <li class="change-item">
                                <strong>🛡️ Schoolboy Siegfried:</strong> Lion Protection cooldown <span class="change-arrow">10 → 6</span> turns, buff duration <span class="change-arrow">5 → 3</span> turns
                            </li>
                            <li class="change-item">
                                <strong>🐰 Farmer Alice:</strong> Pounce stun chance <span class="change-arrow">65% → 85%</span>, duration <span class="change-arrow">4 → 1</span> turn. Bunny Bounce reworked for allies
                            </li>
                            <li class="change-item">
                                <strong>🐺 Renée:</strong> Mystical Whip critical hit formula changed <span class="change-arrow">1400 + 100% → 1000 + 100%</span>
                            </li>
                            <li class="change-item">
                                <strong>⚡ Farmer Raiden:</strong> Electric Shock & Storm Circle now have <span class="change-highlight">80% hit chance</span> per target
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="gameplay-section">
                    <h3>
                        <svg class="notes-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                        Gameplay Improvements
                    </h3>
                    
                    <div class="improvement-item">
                        <h4>🤖 AI Turn Timing Optimization</h4>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> AI turns previously felt sluggish during the planning phase but rushed during action execution, leading to poor gameplay pacing and reduced player engagement.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>AI Planning Speed:</strong> Reduced planning delay <span class="change-arrow">800ms → 400ms</span> per character (50% faster)
                            </li>
                            <li class="change-item">
                                <strong>Planning Transitions:</strong> Reduced delay between character planning <span class="change-arrow">300ms → 200ms</span> (33% faster)
                            </li>
                            <li class="change-item">
                                <strong>Action Execution Pacing:</strong> Increased delay between AI actions <span class="change-arrow">1000ms → 1500ms</span> (50% slower)
                            </li>
                        </ul>
                        <div style="font-size: 0.8rem; color: var(--neutral-400); margin-top: 8px; font-style: italic;">
                            <strong>Impact:</strong> These changes create a more responsive AI experience where players spend less time waiting during the planning phase but have more time to observe and react to each AI action. The improved pacing enhances the tactical feel of combat while maintaining dramatic impact for AI abilities.
                        </div>
                    </div>
                </div>

                <div class="new-character-section">
                    <h3>
                        <svg class="notes-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L15 1H5C3.89 1 3 1.89 3 3V7H1V9H3V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V9H21ZM19 19H5V9H19V19Z"/>
                        </svg>
                        New Playable Character
                    </h3>
                    
                    <div class="character-changes ibuki">
                        <div class="character-name">
                            <span class="character-emoji">🥷</span>
                            <strong>Infernal Ibuki - Balance Adjustments & Quest Integration</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Infernal Ibuki's damage scaling was too high for a character with utility and mobility, making her overpowered in both damage and survivability. The balance changes focus her role as a tactical ninja with moderate damage but strong utility.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Kunai Throw (Q):</strong> Physical damage scaling reduced <span class="change-arrow">150% → 100%</span>
                            </li>
                            <li class="change-item">
                                <strong>Swift Strike (E):</strong> Cooldown reduced <span class="change-arrow">8 → 6</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Smoke Bomb (R):</strong> Cooldown increased <span class="change-arrow">12 → 15</span> turns
                            </li>
                        </ul>
                        <div style="font-size: 0.8rem; color: var(--neutral-400); margin-top: 8px; font-style: italic;">
                            <strong>New Character Quests:</strong> "Blade Master" (Use Kunai Throw 80 times) and "Smoke Specialist" (Apply Smoke Bomb debuff 30 times). Both quests reward +520 XP.
                        </div>
                    </div>
                </div>

                <div class="developer-notes">
                    <h3>
                        <svg class="notes-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                        Developer Notes
                    </h3>
                    <p>This patch focuses primarily on balance adjustments, particularly addressing the overpowered nature of Schoolgirl Julia's healing ability. The changes aim to create more strategic decision-making around healing usage while maintaining character viability.</p>
                    <p>The AI timing improvements should create a more enjoyable combat flow, reducing downtime during AI planning while allowing players to better appreciate each AI action. Infernal Ibuki's adjustments position her as a balanced tactical character rather than an overpowered damage dealer.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Old Changelog Modal (v0.1.1) -->
    <div class="changelog-modal" id="old-changelog-modal">
        <div class="changelog-content">
            <div class="changelog-header">
                <h1 class="changelog-title">
                    🚀 Patch Notes
                    <span class="changelog-version">v0.1.1</span>
                </h1>
                <p class="changelog-subtitle">School Characters Cooldown Balancing</p>
                <button class="changelog-close" onclick="hideOldChangelog()">&times;</button>
            </div>
            
            <div class="changelog-body">
                <div class="changelog-section">
                    <h3>
                        <svg class="notes-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                        </svg>
                        Character Balance Changes
                    </h3>
                    
                    <div class="character-changes siegfried">
                        <div class="character-name">
                            <span class="character-emoji">🛡️</span>
                            <strong>Schoolboy Siegfried</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Siegfried was struggling with long defensive cooldowns, making him less viable in sustained fights.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Lion Protection (W):</strong> Cooldown reduced <span class="change-arrow">15 → 10</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Sword Blessing (E):</strong> Cooldown reduced <span class="change-arrow">12 → 9</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Judgement (R):</strong> Cooldown reduced <span class="change-arrow">25 → 15</span> turns
                            </li>
                        </ul>
                    </div>

                    <div class="character-changes kokoro">
                        <div class="character-name">
                            <span class="character-emoji">💚</span>
                            <strong>Schoolgirl Kokoro</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> As a primary healer/support, Kokoro's abilities were too infrequent to provide consistent team support.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Silencing Ring (W):</strong> Cooldown reduced <span class="change-arrow">15 → 9</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Circle Heal (E):</strong> Cooldown reduced <span class="change-arrow">9 → 8</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Protective Aura (R):</strong> Cooldown reduced <span class="change-arrow">20 → 16</span> turns
                            </li>
                        </ul>
                    </div>

                    <div class="character-changes ayane">
                        <div class="character-name">
                            <span class="character-emoji">🦋</span>
                            <strong>Schoolgirl Ayane</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Ayane's utility and damage abilities were not available frequently enough to maintain her intended role as a mobile damage dealer.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Butterfly Trail (W):</strong> Cooldown reduced <span class="change-arrow">10 → 9</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Quick Reflexes (E):</strong> Cooldown reduced <span class="change-arrow">12 → 11</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Execute Attack (R):</strong> Cooldown reduced <span class="change-arrow">20 → 15</span> turns
                            </li>
                        </ul>
                    </div>

                    <div class="character-changes elphelt">
                        <div class="character-name">
                            <span class="character-emoji">💕</span>
                            <strong>Schoolgirl Elphelt</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Elphelt's longer cooldowns prevented her from effectively controlling enemies and dealing consistent damage.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Affection (E):</strong> Cooldown reduced <span class="change-arrow">12 → 9</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Piercing Bullet (R):</strong> Cooldown reduced <span class="change-arrow">22 → 14</span> turns
                            </li>
                        </ul>
                    </div>

                    <div class="character-changes shoma">
                        <div class="character-name">
                            <span class="character-emoji">⚾</span>
                            <strong>Schoolboy Shoma</strong>
                        </div>
                        <div class="character-rationale">
                            <strong>Rationale:</strong> Shoma's utility abilities needed to be more accessible, and Heavy Ball needed to be more impactful.
                        </div>
                        <ul class="change-list">
                            <li class="change-item">
                                <strong>Catch! (E):</strong> Cooldown reduced <span class="change-arrow">11 → 9</span> turns
                            </li>
                            <li class="change-item">
                                <strong>Heavy Ball:</strong> Debuff duration increased <span class="change-arrow">2 → 4</span> turns
                                <div style="font-size: 0.8rem; color: var(--neutral-400); margin-top: 4px; font-style: italic;">
                                    The Heavy Ball now applies damage reduction for 4 turns instead of 2, making it more strategically valuable
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="developer-notes">
                    <h3>
                        <svg class="notes-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                        Developer Notes
                    </h3>
                    <p>These changes are designed to improve the viability of school faction characters in both story mode and single stages. The reduced cooldowns should allow players to use these characters' signature abilities more frequently, leading to more engaging and dynamic gameplay patterns.</p>
                    <p>The Heavy Ball buff specifically addresses feedback that the debuff duration was too short to be meaningful in longer encounters.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Changelog Modal Functions
        function showChangelog() {
            const modal = document.getElementById('changelog-modal');
            modal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        function hideChangelog() {
            const modal = document.getElementById('changelog-modal');
            modal.classList.remove('show');
            document.body.style.overflow = ''; // Restore scrolling
        }

        function showOldChangelog() {
            const modal = document.getElementById('old-changelog-modal');
            modal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        function hideOldChangelog() {
            const modal = document.getElementById('old-changelog-modal');
            modal.classList.remove('show');
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Close modals when clicking outside
        document.getElementById('changelog-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideChangelog();
            }
        });

        document.getElementById('old-changelog-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideOldChangelog();
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (document.getElementById('changelog-modal').classList.contains('show')) {
                    hideChangelog();
                }
                if (document.getElementById('old-changelog-modal').classList.contains('show')) {
                    hideOldChangelog();
                }
            }
        });
    </script>
</body>
</html> 